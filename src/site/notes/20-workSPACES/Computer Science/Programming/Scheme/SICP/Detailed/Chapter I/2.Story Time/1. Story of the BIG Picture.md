---
{"dg-publish":true,"permalink":"/20-work-spaces/computer-science/programming/scheme/sicp/detailed/chapter-i/2-story-time/1-story-of-the-big-picture/"}
---


up:: 
tags:: 



# 1. Story of the BIG Picture
{ #a23fda}



> [!MIND-MAP STORY]
>
> ## Bilge Kod UstasÄ± ve Soyutlama SanatÄ±
>
> Uzak diyarlarÄ±n birinde, kodlarÄ±n fÄ±sÄ±ltÄ±larla konuÅŸtuÄŸu, algoritmalarÄ±n rÃ¼zgarla dans ettiÄŸi bir vadi varmÄ±ÅŸ. Bu vadinin en bilge kiÅŸisi, Kod UstasÄ± Elara'ymÄ±ÅŸ. Elara, karmaÅŸÄ±k problemleri bile sihirli bir dokunuÅŸla basitleÅŸtiren, "Soyutlama SanatÄ±"nÄ±n ustasÄ±ymÄ±ÅŸ. GenÃ§ Ã§Ä±raklarÄ± Kaan ve Elif, bu sanatÄ± Ã¶ÄŸrenmek iÃ§in her gÃ¼n onun yanÄ±na gelir, anlattÄ±klarÄ±nÄ± can kulaÄŸÄ±yla dinlerlermiÅŸ.
>
> > <span style="color:red;">â‘ </span>
> > > [!TIP]
> > > `Problem: Managing Complexity` {requires} `Principle: Abstraction`
>
> Elara, bir gÃ¼n Ã§Ä±raklarÄ±na dÃ¶nerek, "Ã‡ocuklar," demiÅŸ, "bilgisayarlarla konuÅŸurken karÅŸÄ±laÅŸtÄ±ÄŸÄ±mÄ±z en bÃ¼yÃ¼k zorluk, her ÅŸeyin birbirine girdiÄŸi, iÃ§inden Ã§Ä±kÄ±lmaz hale geldiÄŸi karmaÅŸadÄ±r. **TÄ±pkÄ± dÃ¼ÄŸÃ¼m olmuÅŸ bir yÃ¼n yumaÄŸÄ± gibi.** Ä°ÅŸte bu karmaÅŸayÄ± Ã§Ã¶zmenin, yumaÄŸÄ± aÃ§manÄ±n yolu, Soyutlama dediÄŸimiz sihirli bir prensipten geÃ§er." Kaan merakla sormuÅŸ, "Yani karmaÅŸÄ±k bir sorunu daha basit parÃ§alara ayÄ±rmak gibi mi, Usta?" Elara gÃ¼lÃ¼msemiÅŸ, "Tam olarak Ã¶yle, Kaan. **BÃ¼yÃ¼k bir heykeli yontmadan Ã¶nce nasÄ±l ki kaba hatlarÄ±nÄ± belirler, detaylarÄ± sonraya bÄ±rakÄ±rsak,** karmaÅŸÄ±k bir gÃ¶revi de Ã¶nce genel hatlarÄ±yla ele alÄ±rÄ±z. Bu, zihnimizi gereksiz detaylardan arÄ±ndÄ±rÄ±r ve asÄ±l amaca odaklanmamÄ±zÄ± saÄŸlar."
>
> > <span style="color:red;">â‘¡</span>
> > > [!TIP]
> > > `Principle: Abstraction` {is_implemented_by} `Tool: Procedure Definition`
>
> "Peki Usta," diye atÄ±lmÄ±ÅŸ Elif, "bu soyutlama prensibini nasÄ±l hayata geÃ§iririz? Elimizdeki araÃ§ nedir?" Elara, Ã¶nlerindeki Ã§alÄ±ÅŸma masasÄ±nÄ±n Ã¼zerinde duran parÅŸÃ¶menlere iÅŸaret etmiÅŸ. "Ä°ÅŸte burada," demiÅŸ, "SoyutlamanÄ±n en gÃ¼Ã§lÃ¼ araÃ§larÄ±ndan biri olan 'ProsedÃ¼r TanÄ±mlama' devreye girer. Bir dizi adÄ±mÄ±, bir iÅŸlemi alÄ±r, ona bir isim verir ve onu tek bir birimmiÅŸ gibi kullanmamÄ±zÄ± saÄŸlar. **TÄ±pkÄ± bir aÅŸÃ§Ä±nÄ±n karmaÅŸÄ±k bir yemeÄŸin tarifini tek bir isim altÄ±nda toplamasÄ± gibi; 'KarnÄ±yarÄ±k' dediÄŸimizde, iÃ§ harcÄ±nÄ±n hazÄ±rlanmasÄ±ndan patlÄ±canlarÄ±n kÄ±zartÄ±lmasÄ±na kadar tÃ¼m adÄ±mlarÄ± kastederiz.**"
>
> > <span style="color:red;">â‘¢</span>
> > > [!TIP]
> > > `Tool: Procedure Definition` {requires} `Tool: Primitive Elements`
>
> "Bir prosedÃ¼r tanÄ±mlamak iÃ§in," diye devam etmiÅŸ Elara, parÅŸÃ¶menlerden birini Kaan'a uzatarak, "en temel yapÄ±taÅŸlarÄ±na ihtiyacÄ±mÄ±z var. Bunlar, dilimizin bize sunduÄŸu en basit elemanlardÄ±r: sayÄ±lar gibi 'veriler' ve toplama, Ã§arpma gibi temel 'iÅŸlemler'. **TÄ±pkÄ± bir ressamÄ±n renkleri ve fÄ±rÃ§a darbelerini kullanmasÄ± gibi,** biz de bu 'Ä°lkel ElemanlarÄ±' kullanarak daha karmaÅŸÄ±k yapÄ±lar oluÅŸtururuz. Bir prosedÃ¼r, bu temel elemanlar Ã¼zerine inÅŸa edilir." Kaan parÅŸÃ¶mendeki basit toplama iÅŸlemini gÃ¶steren sembollere bakmÄ±ÅŸ.
>
> > <span style="color:red;">â‘£</span>
> > > [!TIP]
> > > `Tool: Procedure Definition` {requires} `Tool: Means of Combination`
>
> Elara, Elif'e baÅŸka bir parÅŸÃ¶men vermiÅŸ. "Sadece ilkel elemanlar yetmez," demiÅŸ. "Bu elemanlarÄ± bir araya getirmenin, onlarÄ± anlamlÄ± bir ÅŸekilde birleÅŸtirmenin yollarÄ±na da ihtiyacÄ±mÄ±z var. Ã–rneÄŸin, bir iÅŸlemi baÅŸka bir iÅŸlemin iÃ§ine yerleÅŸtirebiliriz; buna 'Ä°Ã§ Ä°Ã§e GeÃ§irme' (Nesting) deriz. Bu 'BirleÅŸtirme YÃ¶ntemleri' sayesinde basit parÃ§alardan karmaÅŸÄ±k desenler oluÅŸturabiliriz, **tÄ±pkÄ± bir mÃ¼zisyenin notalarÄ± birleÅŸtirerek melodiler yaratmasÄ± gibi.** ProsedÃ¼rlerimiz, bu birleÅŸtirme yÃ¶ntemleriyle ilkel elemanlarÄ± anlamlÄ± bir ÅŸekilde Ã¶rer." Elif, parÅŸÃ¶mende iÃ§ iÃ§e geÃ§miÅŸ parantezlerle ifade edilen bir iÅŸlemi incelemiÅŸ.
>
> > <span style="color:red;">â‘¤</span>
> > > [!TIP]
> > > `Tool: Procedure Definition` {requires} `Tool: Means of Abstraction (Naming)`
>
> "Ve tabii ki," diye eklemiÅŸ Elara, "oluÅŸturduÄŸumuz bu birleÅŸik iÅŸlemlere, bu yeni yapÄ±lara bir kimlik vermemiz gerekir. Ä°ÅŸte burada 'Soyutlama YÃ¶ntemleri (Ä°simlendirme)' devreye girer. Lisp/Scheme dilinde `define` komutuyla yaptÄ±ÄŸÄ±mÄ±z gibi, bir iÅŸleme veya bir veriye bir isim atarÄ±z. Bu isim, artÄ±k o karmaÅŸÄ±k yapÄ±nÄ±n bir kÄ±sayolu olur. 'KareAl' diye bir prosedÃ¼r tanÄ±mladÄ±ÄŸÄ±mÄ±zda, artÄ±k sayÄ±yÄ± kendisiyle Ã§arpma iÅŸlemini her seferinde yazmak yerine sadece 'KareAl' deriz. **Bu, dilimize yeni kelimeler eklemek gibidir.**"
>
> > <span style="color:red;">â‘¥</span>
> > > [!TIP]
> > > `Tool: Procedure Definition` {enables} `Solution: Building Abstractions with Procedures`
>
> Kaan heyecanla sormuÅŸ, "Yani Usta, ilkel elemanlarÄ± alÄ±p, birleÅŸtirme yÃ¶ntemleriyle bir araya getirip, sonra da onlara isimler vererek kendi araÃ§larÄ±mÄ±zÄ± mÄ± yaratÄ±yoruz?" Elara baÅŸÄ±yla onaylamÄ±ÅŸ. "Kesinlikle, Kaan. 'ProsedÃ¼r TanÄ±mlama' aracÄ±, iÅŸte tam da bu 'ProsedÃ¼rlerle Soyutlamalar OluÅŸturma' Ã§Ã¶zÃ¼mÃ¼nÃ¼ mÃ¼mkÃ¼n kÄ±lar. ArtÄ±k sadece toplama ve Ã§arpma gibi temel iÅŸlemlerle deÄŸil, `square` (kare_al), `sqrt` (karekÃ¶k_bul) gibi kendi tanÄ±mladÄ±ÄŸÄ±mÄ±z, daha Ã¼st seviye soyutlamalarla dÃ¼ÅŸÃ¼nebilir, problemlerimizi bu soyutlamalarla Ã§Ã¶zebiliriz."
>
> > <span style="color:red;">â‘¦</span>
> > > [!TIP]
> > > `Solution: Building Abstractions with Procedures` {requires} `Tool: Evaluation Model`
>
> Elif merakla sormuÅŸ, "Peki Usta, bilgisayar bu tanÄ±mladÄ±ÄŸÄ±mÄ±z prosedÃ¼rleri, bu soyutlamalarÄ± nasÄ±l anlÄ±yor? OnlarÄ± nasÄ±l Ã§alÄ±ÅŸtÄ±rÄ±yor?" Elara derin bir nefes almÄ±ÅŸ. "GÃ¼zel soru, Elif. 'ProsedÃ¼rlerle Soyutlamalar OluÅŸturma' Ã§Ã¶zÃ¼mÃ¼mÃ¼zÃ¼n iÅŸe yaramasÄ± iÃ§in, bilgisayarÄ±n bu soyutlamalarÄ± nasÄ±l yorumlayacaÄŸÄ±nÄ±, nasÄ±l deÄŸerlendireceÄŸini belirleyen bir 'DeÄŸerlendirme Modeli'ne ihtiyacÄ± var. Bizim kullandÄ±ÄŸÄ±mÄ±z Scheme dilinde bu genellikle 'UygulamalÄ± SÄ±ra (Applicative Order)' ile Ã§alÄ±ÅŸan 'Yerine Koyma Modeli (Substitution Model)'dir. Bilgisayar, bir prosedÃ¼rÃ¼ Ã§alÄ±ÅŸtÄ±rmadan Ã¶nce argÃ¼manlarÄ±nÄ± deÄŸerlendirir, sonra bu deÄŸerleri prosedÃ¼rÃ¼n tanÄ±mÄ±ndaki karÅŸÄ±lÄ±k gelen yerlere koyar. **TÄ±pkÄ± bir tarifteki malzemeleri hazÄ±rlayÄ±p sonra tarife gÃ¶re yemeÄŸi piÅŸirmek gibi.**"
>
> > <span style="color:red;">â‘§</span>
> > > [!TIP]
> > > `Solution: Building Abstractions with Procedures` {uses} `Tool: Conditional Expressions`
>
> "Bazen de," diye devam etmiÅŸ Elara, "prosedÃ¼rlerimizin farklÄ± durumlara gÃ¶re farklÄ± davranmasÄ± gerekir. 'EÄŸer sayÄ± pozitifse ÅŸunu yap, deÄŸilse bunu yap' gibi. Ä°ÅŸte bu noktada 'KoÅŸullu Ä°fadeler' (`cond`, `if`) imdadÄ±mÄ±za yetiÅŸir. Bu araÃ§lar, 'ProsedÃ¼rlerle Soyutlamalar OluÅŸturma' sÃ¼recimizde karar verme mekanizmalarÄ± kurmamÄ±zÄ± saÄŸlar. **TÄ±pkÄ± bir yol ayrÄ±mÄ±nda hangi yÃ¶ne gideceÄŸimize karar vermek gibi.**"
>
> > <span style="color:red;">â‘¨</span>
> > > [!TIP]
> > > `Solution: Building Abstractions with Procedures` {are_analyzed_by} `Analysis: Processes Generated`
>
> Kaan, "Usta," demiÅŸ, "tanÄ±mladÄ±ÄŸÄ±mÄ±z her prosedÃ¼r aynÄ± ÅŸekilde mi Ã§alÄ±ÅŸÄ±r? Yani, bilgisayarÄ±n iÃ§inde hep aynÄ± tÃ¼rden bir hareket mi oluÅŸturur?" Elara gÃ¼lÃ¼msemiÅŸ. "HayÄ±r Kaan. OluÅŸturduÄŸumuz soyutlamalarÄ±n, yani prosedÃ¼rlerin, bilgisayarÄ±n iÃ§inde nasÄ±l bir 'SÃ¼reÃ§ OluÅŸturduÄŸu'nu analiz etmemiz gerekir. BazÄ± prosedÃ¼rler bir iÅŸi adÄ±m adÄ±m, her adÄ±mda bir Ã¶nceki durumun Ã¼zerine koyarak ilerler; buna 'Yinelemeli (Iterative)' sÃ¼reÃ§ deriz. **Bu, sanki bir tespihin tanelerini tek tek Ã§ekmek gibidir; her adÄ±mda bir sonraki taneye geÃ§ilir, sÃ¼reÃ§ belirli bir sayÄ±da tekrar eder ve her adÄ±mda durum, yani hangi tanede olduÄŸumuz, nettir.** BazÄ±larÄ± ise bir problemi daha kÃ¼Ã§Ã¼k alt problemlere ayÄ±rÄ±r, sonra bu alt problemlerin Ã§Ã¶zÃ¼mlerini birleÅŸtirir; buna da 'Ã–zyinelemeli (Recursive)' sÃ¼reÃ§ deriz. **Bu da bir labirentte Ã§Ä±kÄ±ÅŸ yolunu ararken, her yol ayrÄ±mÄ±nda bir yolu deneyip, Ã§Ä±kmaza girince bir Ã¶nceki ayrÄ±ma dÃ¶nÃ¼p diÄŸer yolu denememize benzer; 'yol ara' iÅŸlemi, her yeni yolda kendini tekrar eder, Ã§Ä±kmazsa 'geri dÃ¶n ve baÅŸka bir yol ara' diyerek bir Ã¶nceki duruma, yani bir Ã¶nceki yol ayrÄ±mÄ±na referans verir.**"
>
> > <span style="color:red;">â‘©</span>
> > > [!TIP]
> > > `Analysis: Processes Generated` {is_refined_by} `Analysis: Orders of Growth`
>
> Elif eklemiÅŸ, "Peki bu sÃ¼reÃ§lerin verimliliÄŸini nasÄ±l Ã¶lÃ§eriz, Usta? Hangisinin daha iyi olduÄŸuna nasÄ±l karar veririz?" Elara, "Ä°ÅŸte burada 'BÃ¼yÃ¼me Mertebeleri (Orders of Growth)' analizi devreye girer," demiÅŸ. "Bir sÃ¼recin, problem bÃ¼yÃ¼dÃ¼kÃ§e ne kadar zaman ve ne kadar bellek (alan) tÃ¼kettiÄŸini inceleriz. 'OluÅŸturulan SÃ¼reÃ§lerin Analizi'ni bu metriklerle daha da detaylandÄ±rÄ±rÄ±z. Bir sÃ¼recin lineer mi, logaritmik mi, yoksa Ã¼stel bir bÃ¼yÃ¼me gÃ¶sterdiÄŸini anlamak, programlarÄ±mÄ±zÄ±n bÃ¼yÃ¼k verilerle baÅŸa Ã§Ä±kÄ±p Ã§Ä±kamayacaÄŸÄ±nÄ± Ã¶ngÃ¶rmemizi saÄŸlar. **TÄ±pkÄ± bir yolculuÄŸun ne kadar sÃ¼receÄŸini ve ne kadar yakÄ±t harcayacaÄŸÄ±nÄ± hesaplamak gibi.**"
>
> > <span style="color:red;">â‘ª</span>
> > > [!TIP]
> > > `Principle: Abstraction` {is_enhanced_by} `Tool: Higher-Order Procedures`
>
> Elara, bir sÃ¼re sessiz kalmÄ±ÅŸ, sonra gÃ¶zleri parlayarak devam etmiÅŸ: "Soyutlama prensibimiz, sadece iÅŸlemlere isim vermekle sÄ±nÄ±rlÄ± deÄŸil, Ã§ocuklar. DÃ¼ÅŸÃ¼nÃ¼n ki, sadece sayÄ±larla deÄŸil, prosedÃ¼rlerin kendileriyle Ã§alÄ±ÅŸan prosedÃ¼rler yazabilsek! Ä°ÅŸte bu, 'YÃ¼ksek Mertebeli ProsedÃ¼rler' dediÄŸimiz Ã§ok gÃ¼Ã§lÃ¼ bir araÃ§tÄ±r ve 'Soyutlama' prensibimizi bambaÅŸka bir seviyeye taÅŸÄ±r. Bu araÃ§la, sadece 'ne' yapÄ±lacaÄŸÄ±nÄ± deÄŸil, 'nasÄ±l' yapÄ±lacaÄŸÄ±nÄ±n genel yÃ¶ntemlerini de soyutlayabiliriz."
>
> > <span style="color:red;">â‘«</span>
> > > [!TIP]
> > > `Tool: Higher-Order Procedures` {enables} `Solution: Advanced Abstractions`
>
> Kaan ÅŸaÅŸkÄ±nlÄ±kla, "ProsedÃ¼rlerle Ã§alÄ±ÅŸan prosedÃ¼rler mi?" diye sormuÅŸ. Elara, "Evet Kaan," demiÅŸ. "'YÃ¼ksek Mertebeli ProsedÃ¼rler' aracÄ± sayesinde, bir prosedÃ¼rÃ¼ baÅŸka bir prosedÃ¼re argÃ¼man olarak geÃ§ebilir veya bir prosedÃ¼rÃ¼n sonucunda baÅŸka bir prosedÃ¼r dÃ¶ndÃ¼rebiliriz. Bu, bize 'Ä°leri Seviye Soyutlamalar' oluÅŸturma imkanÄ± tanÄ±r. Ã–rneÄŸin, bir dizi Ã¼zerinde 'toplama' iÅŸlemini genel bir `sum` (toplama) prosedÃ¼rÃ¼ olarak yazabiliriz ve bu `sum` (toplama) prosedÃ¼rÃ¼ne hangi iÅŸlemi (Ã¶rneÄŸin sayÄ±larÄ±n kendisini mi, kÃ¼plerini mi) toplayacaÄŸÄ±nÄ± ve bir sonraki elemana nasÄ±l geÃ§eceÄŸini belirten baÅŸka prosedÃ¼rleri argÃ¼man olarak verebiliriz. BÃ¶ylece `integral` (integral_hesapla), `fixed-point` (sabit_nokta_bul) gibi Ã§ok daha genel ve gÃ¼Ã§lÃ¼ soyutlamalar inÅŸa edebiliriz."
>
> > <span style="color:red;">â‘¬</span>
> > > [!TIP]
> > > `Solution: Building Abstractions with Procedures` {solves} `Problem: Managing Complexity`
>
> Elara sÃ¶zlerini tamamlarken, "Ä°ÅŸte Ã§ocuklar," demiÅŸ, "gÃ¶rdÃ¼ÄŸÃ¼nÃ¼z gibi, 'ProsedÃ¼rlerle Soyutlamalar OluÅŸturma' sÃ¼reci, en temel elemanlardan baÅŸlayarak, birleÅŸtirme ve isimlendirme yoluyla katman katman daha gÃ¼Ã§lÃ¼ araÃ§lar inÅŸa etmemizi saÄŸlar. YÃ¼ksek mertebeli prosedÃ¼rlerle bu gÃ¼cÃ¼ daha da artÄ±rÄ±rÄ±z. Ve tÃ¼m bu Ã§abanÄ±n sonunda, en baÅŸta bahsettiÄŸimiz o bÃ¼yÃ¼k 'KarmaÅŸÄ±klÄ±ÄŸÄ± YÃ¶netme Problemi'ni Ã§Ã¶zmÃ¼ÅŸ oluruz. Soyutlama sanatÄ±, karmaÅŸÄ±k gÃ¶rÃ¼nen dÃ¼nyayÄ± anlamlÄ± ve yÃ¶netilebilir parÃ§alara ayÄ±rma sanatÄ±dÄ±r."
>
> Kaan ve Elif, Kod UstasÄ± Elara'nÄ±n anlattÄ±klarÄ±ndan bÃ¼yÃ¼lenmiÅŸlerdi. SoyutlamanÄ±n sadece bir teknik deÄŸil, aynÄ± zamanda bir dÃ¼ÅŸÃ¼nme biÃ§imi olduÄŸunu anlamÄ±ÅŸlardÄ±. O gÃ¼nden sonra, yazdÄ±klarÄ± her kod satÄ±rÄ±nda, Ã§Ã¶zdÃ¼kleri her problemde Elara'nÄ±n Ã¶ÄŸrettiÄŸi bu sanatÄ± uygulamaya Ã§alÄ±ÅŸtÄ±lar, karmaÅŸÄ±klÄ±ÄŸÄ±n iÃ§inde zarafet ve basitlik aradÄ±lar.
{ #a245a3}




---


---
## ğŸ”‘ Key Points
- 
## â“ Questions
- 
## ğŸ“¦ Resources
- MINDMAP IN PNG: [[1.BigPicture.png]]
-  PODCAST(In Turkish): ![[The Story of Abstraction and Procedures.wav]]
- PODCAST (In English):
![[The Story of Abstraction and Procedures-English.wav]]
## ğŸ¯ Actions
- [ ] 
- [ ] 
- [ ] 
- [ ] 
- [ ] 