---
{"dg-publish":true,"permalink":"/20-work-spaces/computer-science/programming/scheme/sicp/detailed/chapter-i/2-story-time/10-story-of-the-high-order-procedures/"}
---


up:: 
tags:: 



# 10. Story of the High Order Procedures

> [!MIND-MAP STORY]
>
> ## Bilge Kod UstasÄ± Elara ve ProsedÃ¼rlerle Dans Eden ProsedÃ¼rler
>
> Elara, Kaan ve Elif ile bir Ã¶nceki derslerinde sÃ¼reÃ§lerin bÃ¼yÃ¼me mertebelerini (`orders of growth`) ve bunun algoritma seÃ§imindeki Ã¶nemini konuÅŸmuÅŸlardÄ±. BugÃ¼n, Elara onlarÄ± rÃ¼zgarÄ±n melodiler fÄ±sÄ±ldadÄ±ÄŸÄ± bir daÄŸ geÃ§idine, yankÄ±larÄ±n her sesi Ã§oÄŸaltÄ±p dÃ¶nÃ¼ÅŸtÃ¼rdÃ¼ÄŸÃ¼ bir yere getirmiÅŸti.
>
> "Ã‡ocuklar," diye baÅŸladÄ± Elara, sesi rÃ¼zgarla karÄ±ÅŸÄ±yordu. "Åimdiye kadar prosedÃ¼rleri, belirli sayÄ±lar Ã¼zerinde iÅŸlem yapan tarifler gibi dÃ¼ÅŸÃ¼ndÃ¼k. `square` (kare_al) bir sayÄ±nÄ±n karesini alÄ±r, `sqrt` (karekÃ¶k_bul) bir sayÄ±nÄ±n karekÃ¶kÃ¼nÃ¼ bulur. Peki ya, sadece sayÄ±larla deÄŸil, *prosedÃ¼rlerin kendileriyle* Ã§alÄ±ÅŸan, onlarÄ± argÃ¼man olarak alan veya sonuÃ§ olarak yeni prosedÃ¼rler Ã¼reten daha Ã¼st dÃ¼zey soyutlamalar (`abstractions`) yaratabilseydik? Ä°ÅŸte bugÃ¼n, bu gÃ¼Ã§lÃ¼ 'YÃ¼ksek Mertebeli ProsedÃ¼rler'i (`Higher-Order Procedures`) keÅŸfedeceÄŸiz."
>
> Elif ÅŸaÅŸkÄ±nlÄ±kla, "ProsedÃ¼rlerle Ã§alÄ±ÅŸan prosedÃ¼rler mi? Bu nasÄ±l mÃ¼mkÃ¼n olabilir Usta?" diye sordu.
>
> Elara gÃ¼lÃ¼msedi. "**Bir ÅŸef dÃ¼ÅŸÃ¼nÃ¼n. Bu ÅŸefin elinde sadece belirli yemekleri (Ã¶rneÄŸin, mercimek Ã§orbasÄ± veya elmalÄ± turta gibi) piÅŸirmek iÃ§in kullandÄ±ÄŸÄ± sabit tarifler (standart prosedÃ¼rler) olabilir. Ama bir de usta bir ÅŸef hayal edin ki, bu ÅŸefin elinde 'genel piÅŸirme ve sunum ÅŸablonlarÄ±' (yÃ¼ksek mertebeli prosedÃ¼rler) var. Ã–rneÄŸin, 'herhangi bir ana malzemeyi kullanarak ve belirli bir piÅŸirme tekniÄŸi uygulayarak ziyafet yemeÄŸi hazÄ±rla' diye bir genel ÅŸablonu olabilir. Bu ÅŸablona hangi ana malzemeyi (Ã¶rneÄŸin, 'kuzu eti hazÄ±rlama' prosedÃ¼rÃ¼nÃ¼) ve hangi piÅŸirme tekniÄŸini (Ã¶rneÄŸin, 'aÄŸÄ±r ateÅŸte fÄ±rÄ±nlama' prosedÃ¼rÃ¼nÃ¼) vereceÄŸinizi sÃ¶ylersiniz, o da size muhteÅŸem bir ziyafet yemeÄŸi Ã§Ä±karÄ±r. DahasÄ±, bu usta ÅŸef, size verdiÄŸiniz Ã¶zel isteklere gÃ¶re yepyeni, size Ã¶zel bir 'alt tarif' veya 'sunum stili' (sonuÃ§ olarak dÃ¶nen bir prosedÃ¼r) de oluÅŸturabilir. Mesela, 'Belirli bir meyve pÃ¼resini alÄ±p onu kÃ¶pÃ¼ksÃ¼ bir tatlÄ±ya dÃ¶nÃ¼ÅŸtÃ¼ren bir yÃ¶ntem istiyorum' dersiniz, ÅŸef size bu isteÄŸe uygun, daha Ã¶nce hiÃ§ var olmayan yeni bir 'meyve kÃ¶pÃ¼ÄŸÃ¼ yapma' prosedÃ¼rÃ¼ tarif edip verebilir. Ä°ÅŸte YÃ¼ksek Mertebeli ProsedÃ¼rler, programlama dilimizin bu usta ÅŸefleri gibidir; hem var olan genel yÃ¶ntemleri farklÄ± Ã¶zel durumlara ustalÄ±kla uygularlar hem de yepyeni, duruma Ã¶zel yÃ¶ntemler ve iÅŸlevler yaratÄ±rlar.** Onlar sayesinde, sadece 'ne yapÄ±lacaÄŸÄ±nÄ±' deÄŸil, 'nasÄ±l yapÄ±lacaÄŸÄ±nÄ±n genel yÃ¶ntemlerini' de soyutlayabiliriz."
>
> > <span style="color:red;">â‘ </span>
> > > [!TIP]
> > > `Tool: Higher-Order Procedures` {requires} `First-Class Procedures`
>
> Kaan, "Bu 'usta ÅŸef' benzetmesi Ã§ok aydÄ±nlatÄ±cÄ± Usta. Ama bir prosedÃ¼rÃ¼n baÅŸka bir prosedÃ¼rÃ¼ argÃ¼man olarak alabilmesi veya sonuÃ§ olarak dÃ¶ndÃ¼rebilmesi iÃ§in dilimizin buna Ã¶zel bir esneklik sunmasÄ± gerekmez mi?" diye sordu.
>
> "Tam da kalbine dokundun konunun, Kaan," dedi Elara. "YÃ¼ksek Mertebeli ProsedÃ¼rlerin var olabilmesi iÃ§in, kullandÄ±ÄŸÄ±mÄ±z dilde prosedÃ¼rlerin 'Birinci SÄ±nÄ±f VatandaÅŸ' (`First-Class Citizen`) statÃ¼sÃ¼ne sahip olmasÄ± gerekir. Yani, 'Birinci SÄ±nÄ±f ProsedÃ¼rler' (`First-Class Procedures`) olmalÄ±dÄ±rlar. Bu ne demek? **TÄ±pkÄ± bir dildeki kelimelerin sahip olduÄŸu haklar gibi, birinci sÄ±nÄ±f prosedÃ¼rler de ÅŸu temel 'haklara ve ayrÄ±calÄ±klara' (`rights and privileges`) sahiptir:**
> * DeÄŸiÅŸkenlerle isimlendirilebilirler (`named by variables`).
> * BaÅŸka prosedÃ¼rlere argÃ¼man olarak geÃ§irilebilirler (`passed as arguments`).
> * BaÅŸka prosedÃ¼rlerin sonucu olarak dÃ¶ndÃ¼rÃ¼lebilirler (`returned as results`).
> * Veri yapÄ±larÄ±nÄ±n iÃ§ine dahil edilebilirler (`included in data structures`).
> Lisp ve Scheme gibi diller, prosedÃ¼rlere bu tam yetkiyi verir. Bu, onlara muazzam bir ifade gÃ¼cÃ¼ katar."
>
> Elara devam etti, "HatÄ±rlayÄ±n, bir `sum` (toplama) prosedÃ¼rÃ¼ yazmÄ±ÅŸtÄ±k. Bu prosedÃ¼r, belirli bir aralÄ±ktaki sayÄ±larÄ±n kÃ¼plerini toplamak iÃ§in `cube` (kÃ¼p_al) prosedÃ¼rÃ¼nÃ¼ ve bir sonraki sayÄ±ya geÃ§mek iÃ§in `inc` (bir_arttÄ±r) prosedÃ¼rÃ¼nÃ¼ argÃ¼man olarak alÄ±yordu. Ä°ÅŸte `sum` (toplama), YÃ¼ksek Mertebeli bir ProsedÃ¼rdÃ¼r. Benzer ÅŸekilde, bir fonksiyonun integralini (`integral`) veya sabit noktasÄ±nÄ± (`fixed-point` sabit_nokta_bul) bulan prosedÃ¼rler de, Ã¼zerinde Ã§alÄ±ÅŸacaklarÄ± fonksiyonu argÃ¼man olarak alÄ±rlar."
>
> > <span style="color:red;">â‘¡</span>
> > > [!TIP]
> > > `Tool: Higher-Order Procedures` {uses} `lambda`
>
> Elif, "Usta, `sum` (toplama) prosedÃ¼rÃ¼nÃ¼ kullanÄ±rken, toplanacak terimi hesaplayan (`pi-term`) veya bir sonraki deÄŸere geÃ§iÅŸi saÄŸlayan (`pi-next`) gibi Ã§ok basit, tek satÄ±rlÄ±k yardÄ±mcÄ± prosedÃ¼rler tanÄ±mlamak zorunda kalmÄ±ÅŸtÄ±k. Sadece bir kere kullanacaÄŸÄ±mÄ±z bu kÃ¼Ã§Ã¼k iÅŸlevler iÃ§in her seferinde `define` ile isim vermek biraz hantal deÄŸil mi?" diye bir gÃ¶zlemini paylaÅŸtÄ±.
>
> "Ã‡ok haklÄ±sÄ±n Elif," dedi Elara. "Ä°ÅŸte bu noktada `lambda` dediÄŸimiz Ã¶zel bir form imdadÄ±mÄ±za yetiÅŸir. `lambda`, bize isimsiz (`anonymous`) prosedÃ¼rler oluÅŸturma imkanÄ± tanÄ±r. **Sanki bir iÅŸ iÃ§in geÃ§ici bir uzman tutmak gibi; ona resmi bir unvan vermeden, sadece o anki gÃ¶revi tanÄ±mlayÄ±p iÅŸini yapmasÄ±nÄ± istersiniz.** Ã–rneÄŸin, bir sayÄ±yÄ± 4 artÄ±ran bir prosedÃ¼re ihtiyacÄ±mÄ±z varsa, `(lambda (x) (+ x 4))` yazarak o anda, orada bu prosedÃ¼rÃ¼ yaratabilir ve baÅŸka bir YÃ¼ksek Mertebeli ProsedÃ¼re argÃ¼man olarak geÃ§ebiliriz. `pi-sum` (pi_toplamÄ±) prosedÃ¼rÃ¼mÃ¼zÃ¼ `lambda` kullanarak ÅŸu ÅŸekilde daha zarif yazabilirdik: `(sum (lambda (x) (/ 1.0 (* x (+ x 2)))) a (lambda (x) (+ x 4)) b)`. GÃ¶rdÃ¼ÄŸÃ¼n gibi, `pi-term` ve `pi-next` iÃ§in ayrÄ± ayrÄ± `define` yapmamÄ±za gerek kalmadÄ±."
>
> Elara, "YÃ¼ksek Mertebeli ProsedÃ¼rler sadece baÅŸka prosedÃ¼rleri argÃ¼man olarak almakla kalmaz, aynÄ± zamanda sonuÃ§ olarak yeni prosedÃ¼rler de dÃ¶ndÃ¼rebilirler," diye devam etti. "`average-damp` (ortalama_sÃ¶nÃ¼mleyici) diye bir prosedÃ¼r dÃ¼ÅŸÃ¼nÃ¼n. Bu prosedÃ¼r, argÃ¼man olarak bir `f` fonksiyonu alÄ±r ve sonuÃ§ olarak '`x` ile `(f x)`'in ortalamasÄ±nÄ± hesaplayan *yeni bir prosedÃ¼r* dÃ¶ndÃ¼rÃ¼r. Mesela, `(average-damp square)` ifadesi, bize Ã¶yle bir prosedÃ¼r verir ki, bu prosedÃ¼re `10` sayÄ±sÄ±nÄ± uygularsak, `10` ile `(square 10)` yani `100`'Ã¼n ortalamasÄ± olan `55`'i elde ederiz. Benzer ÅŸekilde, bir fonksiyonun tÃ¼revini (`derivative`) hesaplayan `deriv` (tÃ¼rev_al) prosedÃ¼rÃ¼mÃ¼z de, bir `g` fonksiyonunu alÄ±p, onun tÃ¼revi olan baÅŸka bir fonksiyonu dÃ¶ndÃ¼rÃ¼r. `newton-transform` (newton_dÃ¶nÃ¼ÅŸÃ¼mÃ¼) de bir `g` fonksiyonu alÄ±p, Newton metodunda kullanÄ±lacak dÃ¶nÃ¼ÅŸtÃ¼rÃ¼lmÃ¼ÅŸ bir fonksiyon dÃ¶ndÃ¼rÃ¼r. Bu, soyutlama gÃ¼cÃ¼mÃ¼zÃ¼ bir kat daha artÄ±rÄ±r; artÄ±k sadece genel hesaplama yÃ¶ntemlerini deÄŸil, bu yÃ¶ntemleri *Ã¼reten veya dÃ¶nÃ¼ÅŸtÃ¼ren* daha da genel mekanizmalar (`general methods`) inÅŸa edebiliriz. Mesela `fixed-point-of-transform` (dÃ¶nÃ¼ÅŸÃ¼mÃ¼n_sabit_noktasÄ±) gibi bir soyutlama, bir fonksiyonu, o fonksiyonu dÃ¶nÃ¼ÅŸtÃ¼recek bir baÅŸka fonksiyonu ve bir baÅŸlangÄ±Ã§ tahminini alarak, dÃ¶nÃ¼ÅŸtÃ¼rÃ¼lmÃ¼ÅŸ fonksiyonun sabit noktasÄ±nÄ± bulur."
>
> > <span style="color:red;">â‘¢</span>
> > > [!TIP]
> > > `Tool: Higher-Order Procedures` {uses} `let`
>
> Kaan, "Usta, bazen bir prosedÃ¼rÃ¼n iÃ§inde, sadece o prosedÃ¼rÃ¼n kendi hesaplamalarÄ± iÃ§in geÃ§erli olacak geÃ§ici deÄŸiÅŸkenlere veya ara deÄŸerlere isim vermek isteyebiliriz. Mesela, `f(x,y) = x*a^2 + y*b + a*b` gibi bir fonksiyonda, `a = 1 + x*y` ve `b = 1 - y` gibi ara deÄŸerleri kullanmak iÅŸimizi kolaylaÅŸtÄ±rÄ±r. BunlarÄ± nasÄ±l tanÄ±mlarÄ±z?" diye sordu.
>
> "Bu da Ã§ok yaygÄ±n bir ihtiyaÃ§tÄ±r Kaan," dedi Elara. "Bunun iÃ§in `let` dediÄŸimiz Ã¶zel bir yapÄ± kullanÄ±rÄ±z. `let`, bize yerel deÄŸiÅŸkenler (`local variables`) tanÄ±mlama olanaÄŸÄ± sunar. **Sanki bir ressamÄ±n, ana tabloya geÃ§meden Ã¶nce paletinde bazÄ± ara renkleri karÄ±ÅŸtÄ±rÄ±p onlara geÃ§ici isimler ('gÃ¶kyÃ¼zÃ¼ mavisi', 'gÃ¼nbatÄ±mÄ± turuncusu') vermesi ve sonra bu isimleri tablosunda kullanmasÄ± gibi.** `let` ile `a` ve `b` gibi isimleri, belirli ifadelere baÄŸlayabilir ve bu isimleri sadece `let` bloÄŸunun gÃ¶vdesi iÃ§inde kullanabiliriz. Ã–rneÄŸin:
> `(let ((a (+ 1 (* x y))) (b (- 1 y))) (+ (* x (square a)) (* y b) (* a b)))`
> Burada `a` ve `b`, `let` bloÄŸunun dÄ±ÅŸÄ±nda bir anlam taÅŸÄ±maz."
>
> > <span style="color:red;">â‘£</span>
> > > [!TIP]
> > > `let` {is_syntactic_sugar_for} `lambda Application`
>
> Elif, "Bu `let` yapÄ±sÄ± Ã§ok kullanÄ±ÅŸlÄ± gÃ¶rÃ¼nÃ¼yor. Peki, bu dilimize eklenmiÅŸ yepyeni bir mekanizma mÄ±, yoksa bildiÄŸimiz ÅŸeylerin farklÄ± bir sunumu mu?" diye sordu.
>
> Elara gÃ¼lÃ¼msedi. "GÃ¼zel bir soru Elif. AslÄ±nda `let`, dilin temelinde yatan daha ilkel bir mekanizmanÄ±n, yani `lambda` uygulamasÄ±nÄ±n 'sÃ¶zdizimsel bir tatlandÄ±rÄ±cÄ±sÄ±dÄ±r' (`syntactic sugar`). Bir `let` ifadesi, aslÄ±nda yerel deÄŸiÅŸkenleri baÄŸlamak iÃ§in gizli bir `lambda` prosedÃ¼rÃ¼ oluÅŸturup onu hemen uygun deÄŸerlerle Ã§aÄŸÄ±rmanÄ±n kÄ±sa ve okunaklÄ± bir yoludur. Yani,
> `(let ((var1 exp1) (var2 exp2)) body)`
> ifadesi, aslÄ±nda ÅŸuna denktir:
> `((lambda (var1 var2) body) exp1 exp2)`
> GÃ¶rdÃ¼ÄŸÃ¼n gibi, `let` yeni bir sihir getirmiyor; sadece `lambda`'nÄ±n gÃ¼cÃ¼nÃ¼ daha kolay kullanmamÄ±zÄ± saÄŸlÄ±yor. Bu, programcÄ±larÄ±n ortak kalÄ±plarÄ± (`common patterns`) daha rahat ifade edebilmesi iÃ§in dilin sunduÄŸu bir kolaylÄ±ktÄ±r."
>
> Kaan ve Elif, YÃ¼ksek Mertebeli ProsedÃ¼rlerin, `lambda`'nÄ±n ve `let`'in soyutlama (`abstraction`) ve program yapÄ±landÄ±rma (`program structuring`) konusunda ne kadar esnek ve gÃ¼Ã§lÃ¼ araÃ§lar sunduÄŸunu gÃ¶rmÃ¼ÅŸlerdi. ArtÄ±k sadece sabit verilerle deÄŸil, iÅŸlemlerin ve yÃ¶ntemlerin kendileriyle de oynayabilecekleri bir dÃ¼nyanÄ±n kapÄ±larÄ± aralanmÄ±ÅŸtÄ±.
> ```


---

## ğŸ”‘ Key Points
- 
## â“ Questions
- 
## ğŸ“¦ Resources
- PODCAST ENGLISH : ![[YÃ¼ksek Mertebeli ProsedÃ¼rler ve Soyutlama.wav]]
- PODCAST TURKISH:![[YÃ¼ksek Mertebeli ProsedÃ¼rler ve Soyutlama-(Turkish).wav]]
  
- PNG MIND MAP:[[HOF.png]]
## ğŸ¯ Actions
- [ ] 
- [ ] 
- [ ] 
- [ ] 
- [ ] 