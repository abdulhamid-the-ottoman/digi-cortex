---
{"dg-publish":true,"permalink":"/20-work-spaces/computer-science/programming/scheme/sicp/detailed/chapter-i/codebox/8-primality-test/"}
---


up:: 
tags:: 



# 8. Primality Test


## Divisor Test

### Code

```scheme
#lang racket

(define (unfold stop-predicate? item-mapper next-seed-generator initial-seed)
  ;; Generates a list by repeatedly applying functions to a seed.
  ;;
  ;; Args:
  ;;   stop-predicate?: A function (Seed -> Boolean) that returns #t if unfolding should stop.
  ;;   item-mapper:     A function (Seed -> Element) that produces an element for the list from the current seed.
  ;;   next-seed-generator: A function (Seed -> Seed) that produces the next seed.
  ;;   initial-seed:    The starting seed value.
  ;;
  ;; Returns:
  ;;   A list of elements generated by the unfolding process.

  (if (stop-predicate? initial-seed)
      '() ; Base case: If the stop condition is met, return an empty list.
      (cons (item-mapper initial-seed) ; Otherwise, create the current item...
            (unfold stop-predicate?         ; ...and recurse with the next seed.
                    item-mapper
                    next-seed-generator
                    (next-seed-generator initial-seed)))))


(define (functional-sieve n)
  ;; Finds all prime numbers less than or equal to n in a functional style.
  ;;
  ;; Args:
  ;;   n: An integer representing the upper limit (inclusive).
  ;;
  ;; Returns:
  ;;   A list of prime numbers up to n.

  (when (< n 2)
    (error 'functional-sieve "Input must be an integer >= 2. Given:" n))

  ;; Recursive helper function
  (letrec ([kernel (lambda (candidates)
                     (cond
                       [(empty? candidates) '()] ; No more candidates, no more primes
                       [else
                        (let ([p (car candidates)]) ; The first candidate is the next prime
                          ;; Optimization: if p*p > n, then p and all remaining
                          ;; candidates (which are > p) must be prime.
                          ;; Any composite number x <= n would have a prime factor <= sqrt(n).
                          ;; If p > sqrt(n), then any smaller prime factors would have
                          ;; already been processed and filtered out their multiples.
                          (if (> (* p p) n)
                              candidates
                              (cons p ; p is prime
                                    ;; Recursively sieve the rest of the candidates,
                                    ;; after filtering out multiples of p.
                                    (kernel (filter (lambda (x)
                                                      (not (zero? (remainder x p))))
                                                    (cdr candidates))))))]))])
    ;; Initial list of candidates: numbers from 2 to n inclusive.
    ;; `unfold` is a functional way to generate this list.
    ;; (unfold stop? item-generator next-seed-generator initial-seed)
    (kernel (unfold (lambda (current-num) (> current-num n)) ; Stop when current-num exceeds n
                    (lambda (current-num) current-num)       ; The item to add is current-num
                    (lambda (current-num) (+ current-num 1)) ; Next number is current-num + 1
                    2))))                                    ; Start with 2



(define (prime? n)
  (define up-limit (exact-floor (sqrt n))) ; O(1)
  (define primes (functional-sieve up-limit))
  (andmap (lambda (p) (not (zero? (remainder n p)))) primes))


(prime? 11)
```




## Fermat Test

### The Fermat test
- The Fermat test is a Θ(log(n)) primality test based on Fermat’s Little Theorem:

> [!INFO] Theorem
> If p is a prime number and a is any positive integer less than p,  then a raised to the $p^{th}$ power is congruent to a module p
> $a^p \equiv a \ (mod\ p)$ 
---


The test works like this:

1. Given a number p, pick a random number a < p , and calculate $a^p\ mod\ p$
2. Fail: If the result is not equal to a, then p is not prime.
3. Pass: If the result is equal to a, then **p is likely prime.**
4. 1. Repeat. The more times the number passes the test, the more confident we are that p is prime. If there is a single failure, p is certainly not prime.


### Code
```scheme
#lang racket

(define (fermat-test p)
  (let* ([a (random p)]
         [ap (expt a p)])
    (= (remainder ap p) a)))


(define (prime? p)
  (define (trials cnt)
    (cond [(= cnt 0) #t]
          [else (and (fermat-test p)
                     (trials (- cnt 1)))]))
  (trials 3))


(prime? 189) ; #f 
(prime? 11)  ; #t
```


---

## 🔑 Key Points
- 
## ❓ Questions
- 
## 📦 Resources
- 
## 🎯 Actions
- [ ] 
- [ ] 
- [ ] 
- [ ] 
- [ ] 