---
{"dg-publish":true,"permalink":"/20-work-spaces/computer-science/programming/scheme/sicp/detailed/chapter-i/codebox/1-sqrt-procedure/"}
---



up:: 
tags:: 



# 1. sqrt Procedure
## Procedure Definition:

```scheme
(define (sqrt x)
  (define (average a b)
    (/ (+ a b) 2))

  (define (good-enough? guess)
    (< (abs (- (square guess) x)) 0.001)) 

  (define (improve guess)
    (average guess (/ x guess)))

  (define (sqrt-iter guess)
    (if (good-enough? guess)
        guess
        (sqrt-iter (improve guess))))

  (sqrt-iter 1.0))
```

### 1. Top-Level Procedure Definition:Â `sqrt`

- **Code:**Â `(define (sqrt x) ... (sqrt-iter 1.0))`
- **Analysis:**
    - TheÂ `define`Â keyword is the fundamental construct for creating a procedure. This aligns withÂ `Principle: Abstraction`Â {is_implemented_by}Â `Tool: Procedure Definition`Â , as it encapsulates the entire square root calculation logic into a single, abstract unit namedÂ `sqrt`.
    - This definition results in the creation of aÂ `Compound Procedure`, as perÂ `Tool: Procedure Definition`{creates}Â `Compound Procedure`. The identifierÂ `sqrt`Â now refers to this newly defined computational process.
    - The act of naming this procedureÂ `sqrt`Â is a direct application ofÂ `Tool: Procedure Definition`Â {requires}Â `Tool: Means of Abstraction (Naming)`. This name allows the complex iterative algorithm to be invoked simply byÂ `(sqrt x)`.
    - The entireÂ `sqrt`Â structure, with its helper functions, serves as a clear instance ofÂ `Solution: Building Abstractions with Procedures`Â {exemplifies}Â `sqrt Procedure Example`
      
    - By structuring the problem of finding a square root into a main procedure and several helper procedures, this approach directly tackles the challenge of complexity, demonstratingÂ `Solution: Building Abstractions with Procedures`Â {solves}Â `Problem: Managing Complexity`Â 

### 2. Formal Parameter:Â `x`

- **Code:**Â `(define (sqrt x) ...)`Â (specifically theÂ `x`Â in the parameter list)
- **Analysis:**
    - TheÂ `x`Â inÂ `(define (sqrt x) ...)`Â is a formal parameter. Its existence and behavior are governed byÂ `Tool: Procedure Definition`Â {introduces}Â `Local Scope / Bound Variables`Â .Â 
    - `x`Â is bound to theÂ `sqrt`Â procedure; its value is determined whenÂ `sqrt`Â is called, and its scope is limited to the body ofÂ `sqrt`, including the helper functions defined within it, due to lexical scoping.


### 3. Helper Procedure:Â `average`

- **Code:**Â `(define (average a b) (/ (+ a b) 2))`
- **Analysis:**
    - This defines a **local helper procedure**Â `average`. The parametersÂ `a`Â andÂ `b`Â are, likeÂ `x`Â forÂ `sqrt`, local toÂ `average`.
    - The bodyÂ `(/ (+ a b) 2)`Â demonstrates the use ofÂ `Tool: Procedure Definition`Â {requires}Â `Tool: Primitive Elements` , as it employs primitive arithmetic procedures (`+`,Â `/`) and primitive data (the numberÂ `2`, and the numbers thatÂ `a`Â andÂ `b`Â will represent).
    - The expressionÂ `(/ (+ a b) 2)`Â itself is an example of howÂ `Tool: Primitive Elements`Â {are_used_by}Â `Tool: Means of Combination`Â .
    - The structureÂ `(+ a b)`Â andÂ `(/ ... 2)`Â adheres toÂ `Tool: Means of Combination`Â {uses}Â `Prefix Notation`, where the operator precedes the operands.
  
### 4. Helper Procedure:Â `good-enough?`

- **Code:**Â `(define (good-enough? guess) (< (abs (- (square guess) x)) 0.001))`
- **Analysis:**
    - `guess`Â is a local parameter toÂ `good-enough?`.
    - Crucially, this procedure accessesÂ `x`Â (the number whose square root is sought). This is possible due toÂ `Tool: Procedure Definition`Â {supports}Â `Lexical Scoping`Â , where inner procedures (likeÂ `good-enough?`) can access variables defined in their enclosing lexical environments (theÂ `sqrt`Â procedure's environment which includesÂ `x`).
    - The expressionÂ `(square guess)`Â (assumingÂ `square`Â isÂ `(* guess guess)`) represents the use of another abstraction, potentially a primitive or another user-defined procedure.
    - The constantÂ `0.001`Â is a primitive numeric datum.
    - WhenÂ `sqrt-iter`Â callsÂ `(good-enough? guess)`, it exemplifiesÂ `Solution: Building Abstractions with Procedures`Â {uses}Â `Black-Box Abstraction`Â .Â `sqrt-iter`Â relies onÂ `good-enough?`Â to return a boolean value indicating whether the current guess is acceptable, without needing to know the internal comparison logic (i.e., how "good enough" is defined).

### 5. Helper Procedure:Â `improve`

- **Code:**Â `(define (improve guess) (average guess (/ x guess)))`
- **Analysis:**
    - `guess`Â is a local parameter.Â `x`Â is accessed via lexical scoping from theÂ `sqrt`Â procedure.
    - This procedure utilizes the previously definedÂ `average`Â procedure as a black-box abstraction. It passes arguments toÂ `average`Â and uses its result without needing to knowÂ `average`'s internal implementation (`(/ (+ a b) 2)`).
    - It also uses the primitive division operatorÂ `/`.

### 6. Core Iterative Logic:Â `sqrt-iter`

- **Code:**Â `(define (sqrt-iter guess) (if (good-enough? guess) guess (sqrt-iter (improve guess))))`
- **Analysis:**
    - `guess`Â is the state variable for this iterative process.
    - The definition ofÂ `sqrt-iter`Â along withÂ `good-enough?`Â andÂ `improve`Â demonstratesÂ `Solution: Building Abstractions with Procedures`Â {uses}Â `Decomposition`. The problem of iterative refinement is broken down into: checking the guess, improving the guess, and deciding whether to continue.
    - TheÂ `(if (good-enough? guess) guess (sqrt-iter (improve guess)))`Â expression is a direct use ofÂ `Solution: Building Abstractions with Procedures`Â {uses}Â `Tool: Conditional Expressions`. It determines the next step of the computation based on the result ofÂ `(good-enough? guess)`.
    - The recursive callÂ `(sqrt-iter (improve guess))`Â in theÂ `else`Â branch is a tail call. In Scheme implementations that support tail-call optimization, this structure ensures thatÂ `Solution: Building Abstractions with Procedures`Â {are_analyzed_by}Â `Analysis: Processes Generated`Â  leads to anÂ _iterative process_, meaning it executes with constant stack space.
    - `sqrt-iter`Â treats bothÂ `good-enough?`Â andÂ `improve`Â as black-box abstractions.

### 7. Evaluation of a Call, e.g.,Â `(sqrt 25)`

- **Overall Evaluation:**
    - The evaluation ofÂ `(sqrt 25)`Â requires an underlyingÂ `Tool: Means of Combination`Â {requires}Â `Tool: Evaluation Model`Â .
    - TheÂ `Tool: Evaluation Model`Â {uses}Â `Environment`Â  to resolve the meaning ofÂ `sqrt`Â (to find its procedure definition) and laterÂ `x`Â (to bind it toÂ `25`).
    - Scheme's evaluation model for procedure application isÂ `Tool: Evaluation Model`Â {exemplifies}Â `Applicative-Order Evaluation`Â . This means that inÂ `(sqrt 25)`, the argumentÂ `25`Â is evaluated (it evaluates to itself)Â _before_Â theÂ `sqrt`Â procedure body is executed.
    - Conceptually, theÂ `Tool: Evaluation Model`Â {uses}Â `Substitution Model (for Procedures)`Â  for understanding user-defined procedures. WhenÂ `(sqrt 25)`Â is called:
        1. `x`Â is replaced byÂ `25`Â throughout the body ofÂ `sqrt`.
        2. The helper procedures (`average`,Â `good-enough?`,Â `improve`,Â `sqrt-iter`) are effectively defined within an environment whereÂ `x`Â isÂ `25`.
        3. `(sqrt-iter 1.0)`Â is invoked.
        4. In the first call toÂ `sqrt-iter`, itsÂ `guess`Â parameter isÂ `1.0`.
        5. `(good-enough? 1.0)`Â is called. InsideÂ `good-enough?`, itsÂ `guess`Â parameter isÂ `1.0`, andÂ `x`Â isÂ `25`Â from the outer scope.
        6. If false,Â `(improve 1.0)`Â is called. InsideÂ `improve`, itsÂ `guess`Â isÂ `1.0`, andÂ `x`Â isÂ `25`. This produces a new guess.
        7. `sqrt-iter`Â is called with this new guess, and the process repeats.

---

## ðŸ”‘ Key Points
- 
## â“ Questions
- 
## ðŸ“¦ Resources
- 
## ðŸŽ¯ Actions
- [ ] 
- [ ] 
- [ ] 
- [ ] 
- [ ] 