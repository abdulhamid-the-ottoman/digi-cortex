---
{"dg-publish":true,"permalink":"/20-work-spaces/computer-science/programming/scheme/sicp/detailed/chapter-i/2-story-time/7-story-of-the-solution/"}
---


up:: 
tags:: 



# 7. Story of the Solution
> [!MIND-MAP STORY]
>
> ## Bilge Kod UstasÄ± Elara ve SoyutlamanÄ±n GÃ¼cÃ¼yle Problemleri Ã‡Ã¶zmek
>
> Elara, Kaan ve Elif, bir Ã¶nceki derslerinde bilgisayarÄ±n yazdÄ±klarÄ± kodlara nasÄ±l anlam yÃ¼klediÄŸini, yani 'DeÄŸerlendirme Modeli'ni (`Evaluation Model`) kavramÄ±ÅŸlardÄ±. Åimdi, Elara onlarÄ± atÃ¶lyesine, Ã§eÅŸitli karmaÅŸÄ±k aletlerin ve planlarÄ±n olduÄŸu bir ortama gÃ¶tÃ¼rmÃ¼ÅŸtÃ¼. Duvarlarda, ustaca Ã§izilmiÅŸ makinelerin ve yapÄ±larÄ±n ÅŸemalarÄ± asÄ±lÄ±ydÄ±.
>
> Elara, "Ã‡ocuklar," diye baÅŸladÄ±, elindeki bir parÅŸÃ¶meni aÃ§arak. "Åimdiye kadar ilkel elemanlarÄ±, onlarÄ± birleÅŸtirme yollarÄ±nÄ± ve bu birleÅŸimlere isim vererek nasÄ±l prosedÃ¼rler oluÅŸturduÄŸumuzu gÃ¶rdÃ¼k. AyrÄ±ca, bu prosedÃ¼rlerin bilgisayar tarafÄ±ndan nasÄ±l deÄŸerlendirildiÄŸini de anladÄ±k. BugÃ¼n ise tÃ¼m bu bilgileri kullanarak nasÄ±l 'ProsedÃ¼rlerle Soyutlamalar Ä°nÅŸa EttiÄŸimizi' (`Building Abstractions with Procedures`) ve bu yaklaÅŸÄ±mÄ±n karmaÅŸÄ±k problemleri Ã§Ã¶zmede nasÄ±l kilit bir rol oynadÄ±ÄŸÄ±nÄ± inceleyeceÄŸiz."
>
> > <span style="color:red;">â‘ </span>
> > > [!TIP]
> > > `Solution: Building Abstractions with Procedures` {exemplifies} `sqrt Procedure Example`
>
> Elara, parÅŸÃ¶meni masaya yaydÄ±. Ãœzerinde daha Ã¶nceki derslerden tanÄ±dÄ±k bir prosedÃ¼rÃ¼n, karekÃ¶k hesaplayan `sqrt` (karekÃ¶k_bul) prosedÃ¼rÃ¼nÃ¼n ve onun yardÄ±mcÄ±larÄ± olan `sqrt-iter`, `good-enough?` (yeterince_iyi_mi?) ve `improve` (geliÅŸtir) prosedÃ¼rlerinin ÅŸemasÄ± vardÄ±. "BakÄ±n," dedi. "Ä°ÅŸte 'ProsedÃ¼rlerle Soyutlamalar Ä°nÅŸa Etme' Ã§Ã¶zÃ¼mÃ¼nÃ¼n en gÃ¼zel Ã¶rneklerinden biri burada duruyor. `sqrt` (karekÃ¶k_bul) prosedÃ¼rÃ¼mÃ¼z, bir sayÄ±nÄ±n karekÃ¶kÃ¼nÃ¼ bulma gibi karmaÅŸÄ±k bir gÃ¶revi yerine getirirken, aslÄ±nda bu iÅŸi daha kÃ¼Ã§Ã¼k, yÃ¶netilebilir adÄ±mlara bÃ¶len ve her bir adÄ±mÄ± kendi baÅŸÄ±na birer prosedÃ¼r olan yardÄ±mcÄ±larÄ±na devreden bir yapÄ± sergiliyor. **Bu, bÃ¼yÃ¼k bir senfoni orkestrasÄ±nÄ±n, her bir enstrÃ¼man grubunun kendi partisyonunu Ã§alarak muhteÅŸem bir bÃ¼tÃ¼n oluÅŸturmasÄ±na benzer.** `sqrt` (karekÃ¶k_bul) ana orkestra ÅŸefi gibidir, diÄŸer prosedÃ¼rler ise kendi gÃ¶revlerinde uzmanlaÅŸmÄ±ÅŸ mÃ¼zisyenlerdir."
>
> > <span style="color:red;">â‘¡</span>
> > > [!TIP]
> > > `Solution: Building Abstractions with Procedures` {uses} `Decomposition`
>
> Kaan, ÅŸemayÄ± incelerken, "Yani Usta," dedi, "`sqrt` (karekÃ¶k_bul) prosedÃ¼rÃ¼, karekÃ¶k bulma problemini 'tahmin yeterince iyi mi?', 'tahmini nasÄ±l daha iyi yaparÄ±m?' gibi alt problemlere ayÄ±rÄ±yor ve her birini ayrÄ± bir prosedÃ¼rle Ã§Ã¶zÃ¼yor. Bu mudur 'AyrÄ±ÅŸtÄ±rma' (`Decomposition`) dediÄŸiniz ÅŸey?"
>
> Elara onayladÄ±. "Tam da bu, Kaan. 'ProsedÃ¼rlerle Soyutlamalar Ä°nÅŸa Etme' Ã§Ã¶zÃ¼mÃ¼nÃ¼n temelinde yatan gÃ¼Ã§lÃ¼ tekniklerden biri 'AyrÄ±ÅŸtÄ±rma'dÄ±r (`Decomposition`). **TÄ±pkÄ± usta bir saatÃ§inin, karmaÅŸÄ±k bir saati yÃ¼zlerce kÃ¼Ã§Ã¼k ve her biri kendi iÅŸlevini gÃ¶ren parÃ§aya ayÄ±rÄ±p sonra bunlarÄ± bir araya getirerek Ã§alÄ±ÅŸÄ±r bir bÃ¼tÃ¼n oluÅŸturmasÄ± gibi,** biz de bÃ¼yÃ¼k bir problemi daha kÃ¼Ã§Ã¼k, daha kolay anlaÅŸÄ±lÄ±r ve Ã§Ã¶zÃ¼lebilir alt problemlere ayÄ±rÄ±rÄ±z. Her bir alt problemi Ã§Ã¶zen bir prosedÃ¼r yazarÄ±z. `sqrt` (karekÃ¶k_bul) Ã¶rneÄŸinde gÃ¶rdÃ¼ÄŸÃ¼mÃ¼z gibi, `good-enough?` (yeterince_iyi_mi?) bir gÃ¶revi, `improve` (geliÅŸtir) baÅŸka bir gÃ¶revi Ã¼stlenir. Bu sayede genel karmaÅŸÄ±klÄ±k azalÄ±r ve her bir parÃ§ayÄ± ayrÄ± ayrÄ± ele alabilir, test edebilir ve geliÅŸtirebiliriz."
>
> > <span style="color:red;">â‘¢</span>
> > > [!TIP]
> > > `Solution: Building Abstractions with Procedures` {uses} `Black-Box Abstraction`
>
> Elif, "Peki Usta," diye sÃ¶ze girdi, "`sqrt-iter` prosedÃ¼rÃ¼nÃ¼ yazarken, `good-enough?` (yeterince_iyi_mi?) prosedÃ¼rÃ¼nÃ¼n *iÃ§inde* ne olup bittiÄŸini, yani kare alÄ±p fark hesapladÄ±ÄŸÄ±nÄ± bilmek zorunda mÄ±yÄ±z? Yoksa sadece 'bu prosedÃ¼r bana bir tahminin yeterince iyi olup olmadÄ±ÄŸÄ±nÄ± sÃ¶yler' diye mi dÃ¼ÅŸÃ¼nmeliyiz?"
>
> Elara gÃ¼lÃ¼msedi. "Ä°ÅŸte soyutlamanÄ±n (`abstraction`) en gÃ¼zel yanlarÄ±ndan birine deÄŸindin, Elif. 'Kara Kutu SoyutlamasÄ±' (`Black-Box Abstraction`) tam da budur. Bir prosedÃ¼rÃ¼, Ã¶rneÄŸin `good-enough?` (yeterince_iyi_mi?) prosedÃ¼rÃ¼nÃ¼, bir 'kara kutu' olarak dÃ¼ÅŸÃ¼nÃ¼rÃ¼z. **TÄ±pkÄ± bir arabanÄ±n direksiyonunu Ã§evirdiÄŸimizde tekerleklerin nasÄ±l dÃ¶ndÃ¼ÄŸÃ¼nÃ¼n tÃ¼m mekanik detaylarÄ±nÄ± bilmemize gerek olmamasÄ± gibi; sadece direksiyonu Ã§evirince arabanÄ±n dÃ¶neceÄŸini biliriz.** `good-enough?` (yeterince_iyi_mi?) prosedÃ¼rÃ¼nÃ¼n iÃ§ine ne aldÄ±ÄŸÄ± (girdi) ve ne Ã¼rettiÄŸi (Ã§Ä±ktÄ±) ile ilgileniriz, ama bu Ã§Ä±ktÄ±yÄ± nasÄ±l Ã¼rettiÄŸi, yani iÃ§ uygulama detaylarÄ± (`implementation details`) o an iÃ§in bizim iÃ§in Ã¶nemli deÄŸildir. Bu, `sqrt-iter` gibi baÅŸka prosedÃ¼rleri yazarken zihnimizi gereksiz ayrÄ±ntÄ±lardan arÄ±ndÄ±rÄ±r ve sadece mevcut probleme odaklanmamÄ±zÄ± saÄŸlar. `square` (kare_al) prosedÃ¼rÃ¼nÃ¼ kullanÄ±rken de, onun bir sayÄ±nÄ±n karesini hesapladÄ±ÄŸÄ±nÄ± biliriz ama bunu Ã§arpma yoluyla mÄ± yoksa logaritma ve Ã¼s alma yoluyla mÄ± yaptÄ±ÄŸÄ±yla ilgilenmeyiz."
>
> > <span style="color:red;">â‘£</span>
> > > [!TIP]
> > > `Black-Box Abstraction` {is_enabled_by} `Local Scope / Bound Variables`
>
> Kaan, "Usta, bu kara kutu soyutlamasÄ± harika bir fikir. Peki, ya farklÄ± prosedÃ¼rlerde aynÄ± isimleri kullanÄ±rsak ne olur? Mesela, `good-enough?` (yeterince_iyi_mi?) prosedÃ¼rÃ¼nÃ¼n iÃ§indeki bir deÄŸiÅŸkene `x` desek ve `improve` (geliÅŸtir) prosedÃ¼rÃ¼nÃ¼n iÃ§inde de baÅŸka bir amaÃ§la `x` diye bir deÄŸiÅŸken kullansak, bunlar birbirine karÄ±ÅŸmaz mÄ±? Kara kutunun iÃ§i dÄ±ÅŸÄ±nÄ± etkilemez mi?" diye sordu.
>
> Elara, "Bu Ã§ok Ã¶nemli bir nokta, Kaan," dedi. "Kara Kutu SoyutlamasÄ±'nÄ±n saÄŸlam bir ÅŸekilde Ã§alÄ±ÅŸabilmesi, 'Yerel Kapsam' (`Local Scope`) ve 'BaÄŸlÄ± DeÄŸiÅŸkenler' (`Bound Variables`) sayesinde mÃ¼mkÃ¼n olur. Bir prosedÃ¼r tanÄ±mladÄ±ÄŸÄ±mÄ±zda, o prosedÃ¼rÃ¼n formal parametreleri (Ã¶rneÄŸin `(define (kare_al x) (* x x))` ifadesindeki `x`) sadece o prosedÃ¼rÃ¼n gÃ¶vdesi iÃ§inde anlamlÄ±dÄ±r ve oraya 'baÄŸlÄ±dÄ±r'. **Her zanaatkarÄ±n kendi tezgÃ¢hÄ±ndaki aletlerin sadece kendi tezgÃ¢hÄ±nda bir anlam ifade etmesi gibi, bir prosedÃ¼rÃ¼n iÃ§indeki `x` de baÅŸka bir prosedÃ¼rÃ¼n iÃ§indeki `x`'ten tamamen baÄŸÄ±msÄ±zdÄ±r.** `good-enough?` (yeterince_iyi_mi?) prosedÃ¼rÃ¼nÃ¼n `tahmin` ve `x` adÄ±nda parametreleri varsa, bu isimler `good-enough?` (yeterince_iyi_mi?) dÃ¼nyasÄ±na aittir. BaÅŸka bir prosedÃ¼rde de `x` ismi kullanÄ±lsa bile, bu farklÄ± bir `x` olacaktÄ±r. AynÄ± ÅŸekilde, bir prosedÃ¼rÃ¼n iÃ§inde `define` ile tanÄ±mlanan iÃ§ prosedÃ¼rler veya deÄŸiÅŸkenler de sadece o dÄ±ÅŸ prosedÃ¼rÃ¼n kapsamÄ±nda geÃ§erlidir. Bu sayede, prosedÃ¼rler birbirlerinin iÃ§ iÅŸleyiÅŸine mÃ¼dahale etmeden, isim Ã§akÄ±ÅŸmasÄ± korkusu olmadan kara kutular olarak gÃ¼venle kullanÄ±labilirler. Detaylar gerÃ§ekten gizli kalÄ±r (`hiding details`) ve her birim (`coherent unit`) kendi baÅŸÄ±na deÄŸerlendirilebilir."
>
> Kaan ve Elif, soyutlamanÄ±n sadece bir kavram olmadÄ±ÄŸÄ±nÄ±, aynÄ± zamanda programlama dilinin sunduÄŸu bu tÃ¼r mekanizmalarla desteklenen gÃ¼Ã§lÃ¼ bir problem Ã§Ã¶zme stratejisi olduÄŸunu daha iyi anlamÄ±ÅŸlardÄ±. ProsedÃ¼rler, sadece kod parÃ§acÄ±klarÄ± deÄŸil, aynÄ± zamanda iyi tanÄ±mlanmÄ±ÅŸ gÃ¶revleri yerine getiren, birbirleriyle uyum iÃ§inde Ã§alÄ±ÅŸan, gÃ¼venilir araÃ§lardÄ±. Elara'nÄ±n atÃ¶lyesindeki dÃ¼zenli ve her biri kendi amacÄ±na hizmet eden aletler gibi.
> ```
{ #d4a249}


---

## ğŸ”‘ Key Points
- 
## â“ Questions
- 
## ğŸ“¦ Resources
- PODCAST (IN TURKISH) :![[Ã‡Ã¶zÃ¼m Hikayesi_ ProsedÃ¼rlerle Soyutlama.wav]]
- PODCAST (IN ENGLISH):![[Ã‡Ã¶zÃ¼m Hikayesi_ ProsedÃ¼rlerle Soyutlama-(InEnglish).wav]]
- PNG MIND MAP :[[7.Solution 1.png]]
## ğŸ¯ Actions
- [ ] 
- [ ] 
- [ ] 
- [ ] 
- [ ] 