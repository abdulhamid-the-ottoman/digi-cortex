---
{"dg-publish":true,"permalink":"/20-work-spaces/computer-science/programming/scheme/sicp/detailed/chapter-i/2-story-time/9-story-of-the-growth-order/"}
---


up:: 
tags:: 



# 9. Story of the Growth Order
> [!MIND-MAP STORY]
>
> ## Bilge Kod UstasÄ± Elara ve SÃ¼reÃ§lerin BÃ¼yÃ¼me HÄ±zlarÄ±
>
> Elara, Kaan ve Elif, bir Ã¶nceki derslerinde farklÄ± prosedÃ¼rlerin bilgisayarÄ±n iÃ§inde nasÄ±l farklÄ± 'sÃ¼reÃ§ ÅŸekilleri' (process shapes) oluÅŸturduÄŸunu â€“ doÄŸrusal Ã¶zyinelemeli, doÄŸrusal yinelemeli ve aÄŸaÃ§ Ã¶zyinelemesi gibi â€“ ve bu ÅŸekillerin bellek kullanÄ±mÄ± Ã¼zerindeki etkilerini konuÅŸmuÅŸlardÄ±. BugÃ¼n, Elara onlarÄ± geniÅŸ bir ovaya bakan bir tepenin Ã¼zerine Ã§Ä±karmÄ±ÅŸtÄ±. AÅŸaÄŸÄ±da, farklÄ± bÃ¼yÃ¼klÃ¼klerdeki tarlalar ve onlara giden Ã§eÅŸitli yollar gÃ¶rÃ¼nÃ¼yordu.
>
> Elara, "Ã‡ocuklar," dedi, eliyle ovayÄ± iÅŸaret ederek. "DÃ¼n sÃ¼reÃ§lerin nasÄ±l aktÄ±ÄŸÄ±nÄ±, nasÄ±l ÅŸekillendiÄŸini gÃ¶rdÃ¼k. Peki, bir sÃ¼recin, problem bÃ¼yÃ¼dÃ¼kÃ§e ne kadar zaman veya ne kadar bellek (alan) tÃ¼kettiÄŸini nasÄ±l Ã¶lÃ§eriz? Bir algoritmanÄ±n diÄŸerinden neden daha 'hÄ±zlÄ±' veya daha 'verimli' olduÄŸunu nasÄ±l anlarÄ±z? Ä°ÅŸte bugÃ¼n, bu sorularÄ±n cevabÄ±nÄ± arayacaÄŸÄ±mÄ±z 'BÃ¼yÃ¼me Mertebeleri' (`Orders of Growth`) analizini konuÅŸacaÄŸÄ±z."
>
> Kaan, "Yani Usta, bir programÄ±n ne kadar 'iyi' olduÄŸunu anlamak iÃ§in bir Ã¶lÃ§Ã¼m sistemi mi bu?" diye sordu.
>
> "Bir bakÄ±ma evet, Kaan," dedi Elara. "Bir sÃ¼recin, uÄŸraÅŸtÄ±ÄŸÄ± problemin boyutu (`n`) bÃ¼yÃ¼dÃ¼kÃ§e ne kadar kaynaÄŸa â€“ genellikle zaman adÄ±mÄ± (`steps`) veya bellek alanÄ± (`space`) â€“ ihtiyaÃ§ duyduÄŸunu ifade etmenin bir yoludur. Bir sÃ¼recin kaynak kullanÄ±mÄ± `R(n)` olsun. EÄŸer `R(n)`'nin bÃ¼yÃ¼me hÄ±zÄ±, `n` bÃ¼yÃ¼dÃ¼kÃ§e `f(n)` adlÄ± bir fonksiyonun bÃ¼yÃ¼me hÄ±zÄ±na benziyorsa, bunu `R(n) = Î˜(f(n))` (Theta f-of-n diye okunur) ÅŸeklinde ifade ederiz. Bu, `n` yeterince bÃ¼yÃ¼dÃ¼ÄŸÃ¼nde, `R(n)` deÄŸerinin, `k1 * f(n)` ile `k2 * f(n)` gibi iki sabit kat arasÄ±nda sÄ±kÄ±ÅŸtÄ±ÄŸÄ± anlamÄ±na gelir. **Sanki bir fidanÄ±n yÄ±llara gÃ¶re boyunun nasÄ±l uzayacaÄŸÄ±nÄ± tahmin etmek gibi; kesin milimetrik deÄŸeri deÄŸil ama 'bu fidan yÄ±lda ortalama ÅŸu kadar santim ile bu kadar santim arasÄ±nda bÃ¼yÃ¼r' diyerek genel bir bÃ¼yÃ¼me karakteristiÄŸi belirleriz.**"
>
> > <span style="color:red;">â‘ </span>
> > > [!TIP]
> > > `Î˜(log n)` {is_better_than} `Î˜(n)`
>
> Elif, "Peki Usta, farklÄ± `f(n)` fonksiyonlarÄ± ne anlama geliyor? Mesela `Î˜(log n)` (logaritmik) ile `Î˜(n)` (doÄŸrusal) arasÄ±nda nasÄ±l bir fark var?" diye sordu.
>
> Elara, aÅŸaÄŸÄ±daki tarlalara giden yollardan ikisini gÃ¶sterdi. Biri neredeyse dÃ¼mdÃ¼z ve kÄ±sa gÃ¶rÃ¼nÃ¼yordu, diÄŸeri ise daha uzun ama hafif bir eÄŸimle yÃ¼kseliyordu. "DÃ¼ÅŸÃ¼nÃ¼n ki, bir hedefe ulaÅŸmak iÃ§in farklÄ± yollarÄ±mÄ±z var. `Î˜(log n)` yani logaritmik bÃ¼yÃ¼me, **sanki hedefe ulaÅŸmak iÃ§in sihirli bir haritanÄ±z varmÄ±ÅŸ da, problem ne kadar bÃ¼yÃ¼rse bÃ¼yÃ¼sÃ¼n, harita size her adÄ±mda kalan yolun Ã¶nemli bir kÄ±smÄ±nÄ± atlatÄ±yormuÅŸ gibi dÃ¼ÅŸÃ¼nÃ¼lebilir. Problem boyutu iki katÄ±na Ã§Ä±ktÄ±ÄŸÄ±nda, gereken adÄ±m sayÄ±sÄ± sadece bir miktar artar.** Buna karÅŸÄ±lÄ±k, `Î˜(n)` yani doÄŸrusal bÃ¼yÃ¼me, **sanki hedefe sabit bir hÄ±zla yÃ¼rÃ¼mek gibidir; problem boyutu (mesafe) iki katÄ±na Ã§Ä±karsa, gereken adÄ±m sayÄ±sÄ± (zaman) da kabaca iki katÄ±na Ã§Ä±kar.** Bu yÃ¼zden, bÃ¼yÃ¼k problemlerle uÄŸraÅŸÄ±rken, logaritmik bÃ¼yÃ¼yen bir algoritma, doÄŸrusal bÃ¼yÃ¼yen bir algoritmadan Ã§ok daha verimli olur. `fast-expt` (hÄ±zlÄ±_Ã¼s_alma) prosedÃ¼rÃ¼mÃ¼z logaritmik adÄ±mlarla Ã§alÄ±ÅŸÄ±rken, faktÃ¶riyel hesaplayan ilk prosedÃ¼rÃ¼mÃ¼z doÄŸrusal adÄ±mlarla Ã§alÄ±ÅŸÄ±yordu."
>
> > <span style="color:red;">â‘¡</span>
> > > [!TIP]
> > > `Î˜(n)` {is_better_than} `Î˜(n^2)`
>
> Kaan, "AnlÄ±yorum Usta. Peki ya `Î˜(n)` (doÄŸrusal) ile `Î˜(n^2)` (karesel â€“ n Ã¼zeri 2) arasÄ±nda nasÄ±l bir karÅŸÄ±laÅŸtÄ±rma yapabiliriz?"
>
> Elara, "DoÄŸrusal bÃ¼yÃ¼me, problemi bir kere baÅŸtan sona taramak gibi dÃ¼ÅŸÃ¼nÃ¼lebilir," diye aÃ§Ä±kladÄ±. "Karesel bÃ¼yÃ¼me ise, **sanki elinizdeki her bir Ã¶ÄŸe iÃ§in, listedeki diÄŸer tÃ¼m Ã¶ÄŸelere tek tek bakmanÄ±z gerekiyormuÅŸ gibi bir durumdur. Bir grup insan arasÄ±nda herkesin herkesle tokalaÅŸmasÄ± gibi; insan sayÄ±sÄ± `n` ise, tokalaÅŸma sayÄ±sÄ± kabaca `n^2` ile orantÄ±lÄ± olur.** Problem boyutu biraz arttÄ±ÄŸÄ±nda, gereken adÄ±m sayÄ±sÄ± Ã§ok daha fazla artar. EÄŸer `n` 10 ise, `n^2` 100'dÃ¼r. Ama `n` 100 ise, `n^2` 10,000 olur! Bu nedenle, bÃ¼yÃ¼k `n` deÄŸerleri iÃ§in doÄŸrusal bir algoritma, karesel bir algoritmadan Ã¶nemli Ã¶lÃ§Ã¼de daha iyi performans gÃ¶sterir."
>
> > <span style="color:red;">â‘¢</span>
> > > [!TIP]
> > > `Î˜(n^2)` {is_better_than} `Î˜(b^n)`
>
> Elif, "Demek ki karesel bÃ¼yÃ¼me de pek tercih edilen bir durum deÄŸil. Peki, ondan daha kÃ¶tÃ¼ olanlar var mÄ±?" diye sordu merakla.
>
> "Evet Elif," dedi Elara ciddi bir ifadeyle. "Ãœstel bÃ¼yÃ¼me (`Exponential Growth`), yani `Î˜(b^n)` (b Ã¼zeri n, burada `b` birden bÃ¼yÃ¼k bir sabittir), genellikle baÅŸa Ã§Ä±kÄ±lmasÄ± en zor olanÄ±dÄ±r. **Bu, sanki Ã§Ã¶zmeniz gereken problemin her bir kÃ¼Ã§Ã¼k parÃ§asÄ± iÃ§in, iki veya daha fazla yeni alt probleme yol aÃ§an bir yol ayrÄ±mÄ±na gelmek gibidir. Problem boyutu sadece bir birim arttÄ±ÄŸÄ±nda bile, gereken iÅŸlem miktarÄ± bir Ã¶ncekiyle Ã§arpÄ±larak katlanÄ±r!** AÄŸaÃ§ Ã¶zyinelemesiyle hesapladÄ±ÄŸÄ±mÄ±z Fibonacci sayÄ±larÄ± (`Fibonacci numbers`) buna bir Ã¶rnekti; `Î˜(Ï†^n)` gibi Ã¼stel bir bÃ¼yÃ¼me sergiliyordu. Karesel bir algoritma bÃ¼yÃ¼k `n`'ler iÃ§in yavaÅŸ kalabilirken, Ã¼stel bir algoritma Ã§ok daha kÃ¼Ã§Ã¼k `n` deÄŸerlerinde bile pratik olarak kullanÄ±lamaz hale gelebilir. **Sanki bir piramit ÅŸemasÄ± gibi; her seviyede iÅŸ katlanarak artar.** Bu yÃ¼zden, bir problemin Ã¼stel zamanda Ã§Ã¶zÃ¼ldÃ¼ÄŸÃ¼nÃ¼ gÃ¶rdÃ¼ÄŸÃ¼mÃ¼zde, genellikle daha verimli bir yol bulmaya Ã§alÄ±ÅŸÄ±rÄ±z."
>
> > <span style="color:red;">â‘£</span>
> > > [!TIP]
> > > `Analysis: Orders of Growth` {informs} `Algorithm Choice`
>
> Kaan, "Usta, tÃ¼m bu farklÄ± bÃ¼yÃ¼me mertebelerini anlamak, bize nasÄ±l bir fayda saÄŸlar? Sadece 'bu hÄ±zlÄ±, bu yavaÅŸ' demekten Ã¶te bir anlamÄ± var mÄ±?"
>
> Elara baÅŸÄ±yla onayladÄ±. "Kesinlikle var, Kaan. BÃ¼yÃ¼me Mertebeleri analizi, bizim iÃ§in 'Algoritma SeÃ§imi'nde (`Algorithm Choice`) hayati bir rehberdir. **TÄ±pkÄ± bir yolculuÄŸa Ã§Ä±kmadan Ã¶nce farklÄ± ulaÅŸÄ±m araÃ§larÄ±nÄ±n (algoritmalarÄ±n) ne kadar sÃ¼rede (zaman karmaÅŸÄ±klÄ±ÄŸÄ±) ve ne kadar yakÄ±tla (alan karmaÅŸÄ±klÄ±ÄŸÄ±) bizi hedefe ulaÅŸtÄ±racaÄŸÄ±nÄ± karÅŸÄ±laÅŸtÄ±rmak gibi.** EÄŸer kÃ¼Ã§Ã¼k bir kasabaya gidiyorsak (kÃ¼Ã§Ã¼k `n`), belki yavaÅŸ ama keyifli bir yol (basit bir algoritma) sorun olmaz. Ama kÄ±talararasÄ± bir yolculuk yapacaksak (bÃ¼yÃ¼k `n`), en hÄ±zlÄ± ve verimli aracÄ± (daha dÃ¼ÅŸÃ¼k bÃ¼yÃ¼me mertebesine sahip algoritmayÄ±) seÃ§mek isteriz. Ã–rneÄŸin, faktÃ¶riyel iÃ§in doÄŸrusal Ã¶zyinelemeli (`Î˜(n)` adÄ±m, `Î˜(n)` alan) ve doÄŸrusal yinelemeli (`Î˜(n)` adÄ±m, `Î˜(1)` alan) iki yÃ¶ntemimiz vardÄ±. Ä°kisi de adÄ±m sayÄ±sÄ± aÃ§Ä±sÄ±ndan aynÄ± mertebede olsa da, yinelemeli olanÄ±n sabit alan kullanÄ±mÄ± onu bÃ¼yÃ¼k `n`'ler iÃ§in daha Ã§ekici kÄ±lar. Ã–klid'in algoritmasÄ±yla EBOB (`GCD`) bulmak `Î˜(log n)` adÄ±mda biterken, asal sayÄ±larÄ± deneme bÃ¶lmesiyle (`trial division`) bulmak `Î˜(âˆšn)` adÄ±m sÃ¼rer, Fermat testiyle asallÄ±k kontrolÃ¼ ise yine `Î˜(log n)` adÄ±mda yapÄ±labilir. Bu analizler, hangi yÃ¶ntemin ne zaman daha uygun olacaÄŸÄ±na karar vermemize yardÄ±mcÄ± olur."
>
> Elif ve Kaan, tepeden ovadaki farklÄ± yollarÄ± ve tarlalarÄ± izlerken, artÄ±k sadece fiziksel ÅŸekilleri deÄŸil, aynÄ± zamanda onlara ulaÅŸmak iÃ§in gereken 'Ã§abanÄ±n' farklÄ± bÃ¼yÃ¼me hÄ±zlarÄ±nÄ± da hayal edebiliyorlardÄ±. Bir algoritmanÄ±n sadece doÄŸru Ã§alÄ±ÅŸmasÄ±nÄ±n yetmediÄŸini, aynÄ± zamanda kaynaklarÄ± da akÄ±llÄ±ca kullanmasÄ± gerektiÄŸini daha iyi anlamÄ±ÅŸlardÄ±.
> ```
{ #6148ea}


---

## ğŸ”‘ Key Points
- 
## â“ Questions
- 
## ğŸ“¦ Resources
- PODCAST(IN TURKISH):![[BÃ¼yÃ¼me Mertebeleri_ Algoritma VerimliliÄŸi Analizi.wav]]
- PODCAST(IN ENGLISH):![[BÃ¼yÃ¼me Mertebeleri_ Algoritma VerimliliÄŸi Analizi-2.wav]]
- PNG MINDMAP:[[OrderOfGrowth.png]]
## ğŸ¯ Actions
- [ ] 
- [ ] 
- [ ] 
- [ ] 
- [ ] 