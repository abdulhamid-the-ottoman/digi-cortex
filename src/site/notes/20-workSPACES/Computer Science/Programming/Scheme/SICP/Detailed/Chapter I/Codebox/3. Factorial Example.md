---
{"dg-publish":true,"permalink":"/20-work-spaces/computer-science/programming/scheme/sicp/detailed/chapter-i/codebox/3-factorial-example/"}
---


up:: 
tags:: 



# 3. Factorial Example

## Naive Recursive Implementation

### Code

```scheme
#lang racket

(define (factorial n)
  (if (< n 1)
      1
      (* n (factorial (- n 1)))))
```
### Trace

```Scheme
(factorial 4) 
(* 4 (factorial 3)) 
(* 4 (* 3 (factorial 2))) 
(* 4 (* 3 (* 2 (factorial 1)))) 
(* 4 (* 3 (* 2 1))) 
(* 4 (* 3 2)) 
(* 4 6) 
24
```

### Explanation

1. **Process Type:**Â ThisÂ `factorial`Â function generates aÂ **`Linear Recursive Process`Â **.
- The trace shows a chain ofÂ **`deferred operations`**Â (the multiplications likeÂ `* 4`,Â `* 3`,Â `* 2`). The function must wait for the result of the inner recursive call (`factorial (- n 1)`) before it can perform the multiplication. 
- This "waiting" is the hallmark described inÂ **[!TIP] â‘ **:Â _"Her Ã§aÄŸrÄ±, bir sonraki adÄ±ma geÃ§meden Ã¶nce bir 'ertelenmiÅŸ iÅŸlem' (`deferred operation`) biriktirir."_

2. **Space Usage:**Â This process exhibitsÂ **`Growing Space Usage (Often Linear)`Â ([!TIP] â‘¡Â `Linear Recursive Process`{has_characteristic}Â `Growing Space Usage (Often Linear)`)**.
    
    - EachÂ `deferred operation`Â requires memory to store its pending state. AsÂ `n`Â (inÂ `(factorial n)`) increases, the chain of these deferred operations grows, leading to increased memory consumption, reflecting the idea that more "note paper" is needed for a longer list of pending jobs.
      
- **Contrast with Iterative Process:**Â ThisÂ **`Linear Recursive Process`Â {differs_from}Â `Linear Iterative Process`([!TIP] â‘¤)**.
    
    - An iterative process (as described inÂ **[!TIP] â‘¢Â `Analysis: Processes Generated`Â {details}Â `Linear Iterative Process`**) would typically maintain its state in a fixed number of variables and wouldn't accumulate deferred operations, thus havingÂ **`Constant Space Usage`Â ([!TIP] â‘£Â `Linear Iterative Process`Â {has_characteristic}Â `Constant Space Usage`)**. OurÂ `factorial`Â is not iterative in itsÂ _process_Â shape due to these pending multiplications.

### What exactly is this required space?
> [!QUESTION]
> - Where does this required space emanate from? 
> 	  - Does it emanate from the deferred multiplication operations?
> 	  - Does it emanate from the recursive calls?
> - What exactly requires space?

- We already know that the deferred operations `factorial`Â example are a direct consequence of the recursive callÂ `(factorial (- n 1))`Â not being in a tail position.

- It's theÂ **execution context**Â that needs to be preserved for each active recursive call that has a pending (deferred) operation.
- This context is typically stored in what's called a "stack frame" on the program's call stack.


- Let's break down what this context includes for each step ofÂ `(factorial 4)`:

	1. **Call:Â `(factorial 4)`**
	    - Evaluates toÂ `(* 4 (factorial 3))`.
	    - **Space Required for this Frame:**
	        - **Recursive Call Information:**Â It needs to know thatÂ `(factorial 3)`Â has been called and it's waiting for its result.
	        - **Deferred Operation Data:**Â It must remember the valueÂ `4`Â (theÂ `n`Â for this frame) and the operationÂ `*`Â that needs to be applied toÂ `4`Â and the result ofÂ `(factorial 3)`.
	        - **Return Address:** Where to go in the program afterÂ `(factorial 4)`Â itself completes.
	          
	2. **Call:Â `(factorial 3)`Â (called byÂ `(factorial 4)`)**
	    - Evaluates toÂ `(* 3 (factorial 2))`.
	    - **Space Required for this New Frame:**
	        - Recursive Call Information: Waiting forÂ `(factorial 2)`.
	        - Deferred Operation Data: Must remember itsÂ `n`, which isÂ `3`, and the pendingÂ `*`Â operation.
	        - Return Address: Where to returnÂ _within the computation ofÂ `(* 4 (factorial 3))`_Â afterÂ `(factorial 3)`Â completes.
	          
	3. **Call:Â `(factorial 2)`Â (called byÂ `(factorial 3)`)**
	    - Evaluates toÂ `(* 2 (factorial 1))`.
	    - **Space Required for this New Frame:**
	        - Recursive Call Information: Waiting forÂ `(factorial 1)`.
	        - Deferred Operation Data: Must remember itsÂ `n`, which isÂ `2`, and the pendingÂ `*`Â operation.
	          
	4. **Call:Â `(factorial 1)`Â (called byÂ `(factorial 2)`)**
	    - `(factorial 1)`Â is treated as a base case resolving toÂ `1`Â (as your traceÂ `(* 4 (* 3 (* 2 1)))`Â suggests was the outcome forÂ `(factorial 1)`): 
		    - This particular call might not add much to the chain ofÂ _deferred multiplications_Â if it itself doesn't defer another multiplication. 
		    - However, the call itself occupies a frame until it returns.

- The key is thatÂ **each time a recursive call is made AND there's an operation pending on its result, a new portion of memory (a stack frame) is used to store the information for that pending operation and the state of the current call.**

	- So, it's not just the "multiplication operations" in isolation, nor just the "recursive calls" in isolation.
	- It's theÂ **combination**: each recursive call that isÂ _not in tail position_Â implies there's a "job left to do" (the deferred operation). To remember these jobs, their parameters, and where to resume, space is needed.
## Iterative Factorial
### Code
```scheme
#lang racket

(define (factorial n)
  ; Define an inner helper function 'fact-iter'
  (define (fact-iter result state)
    (cond [(<= state 1) result] ; Base case: If state is 1 or less, return the accumulated result
          [else (fact-iter (* result state) ; Recursive step: Call fact-iter again with...
                           (- state 1))]))  ; ...updated result and decremented state
  ; Initial call to the helper function
  (fact-iter 1 n)) ; Start with result = 1 and state = n
```

### Trace
```Scheme
(factorial 4) 
(fact-iter 1 4) 
(fact-iter 4 3)
(fact-iter 12 2)
(fact-iter 24 1) 
24
```

### Explanation
1. **Process Type:**Â ThisÂ `factorial`Â implementation generates aÂ **`Linear Iterative Process`Â ([!TIP] â‘¢Â `Analysis: Processes Generated`Â {details}Â `Linear Iterative Process`)**.
    
    - The trace shows that the state of the computation at any point is completely summarized by the current values ofÂ `result`Â andÂ `state`. There are no pending orÂ **`deferred operation`s**Â waiting to be executed later. Each step directly calculates the next state based on the current one. This matches Elara's description:Â _"O anda Ã¶nemli olan sadece kilin mevcut ÅŸekli... tÃ¼m bilgi, o anki durumun kendisindedir ve bir sonraki dokunuÅŸla gÃ¼ncellenir."_Â (What matters at that moment is just the current shape of the clay... all information is in the current state itself and is updated with the next touch.)
      
2. **Space Usage:**Â This process exhibitsÂ **`Constant Space Usage`Â ([!TIP] â‘£Â `Linear Iterative Process`{has_characteristic}Â `Constant Space Usage`)**.
    - Because there's no buildup of deferred operations, the amount of memory required to track the process's state (`result`Â andÂ `state`) remains fixed, regardless of how largeÂ `n`Â is. This aligns with Elara's marathon runner analogy:Â _"yanÄ±nda taÅŸÄ±masÄ± gereken bilgi yÃ¼kÃ¼ yarÄ±ÅŸÄ±n uzunluÄŸuna gÃ¶re artmaz."_Â (The information load they need to carry doesn't increase with the length of the race.)
      
3. **Syntax vs. Process & Tail Recursion:**Â This is a key example whereÂ **`Recursive Procedure Syntax`{can_generate}Â `Iterative Process`Â {if}Â `Tail-Recursive Implementation exists`Â ([!TIP] â‘¥)**.
    - TheÂ `fact-iter`Â functionÂ _is_Â syntactically recursive (it calls itself). However, the recursive callÂ `(fact-iter (* result state) (- state 1))`Â is theÂ _very last_Â operation performed in theÂ `else`Â branch. There's nothing else to do after this call returns. This is aÂ **`Tail-Recursive Implementation`**Â (or "tail call").
    - Racket implementations are designed to optimize tail calls. They can execute this code using aÂ **`Linear Iterative Process`**, effectively reusing the same memory space (like Elara's artisan using the same workbench) for each step, instead of allocating new space for each call as a non-tail-recursive function would.
---

## ðŸ”‘ Key Points
- 
## â“ Questions
- 
## ðŸ“¦ Resources
- 
## ðŸŽ¯ Actions
- [ ] 
- [ ] 
- [ ] 
- [ ] 
- [ ] 