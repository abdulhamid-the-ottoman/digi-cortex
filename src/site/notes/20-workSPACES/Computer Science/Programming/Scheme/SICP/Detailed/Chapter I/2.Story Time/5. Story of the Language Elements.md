---
{"dg-publish":true,"permalink":"/20-work-spaces/computer-science/programming/scheme/sicp/detailed/chapter-i/2-story-time/5-story-of-the-language-elements/"}
---


up:: 
tags:: 



# Story of the Language Elements

> [!MIND-MAP STORY]
>
> ## Bilge Kod UstasÄ± Elara, Ã‡Ä±raklarÄ± ve ProgramlamanÄ±n YapÄ±taÅŸlarÄ±
>
> Elara, Kaan ve Elif, Soyutlama SanatÄ± Ã¼zerine konuÅŸtuklarÄ± bir Ã¶nceki gÃ¼nÃ¼n ardÄ±ndan tekrar bir araya gelmiÅŸlerdi. Vadinin huzurlu sessizliÄŸinde, Elara Ã§Ä±raklarÄ±na programlamanÄ±n daha derin sÄ±rlarÄ±nÄ± aralamaya hazÄ±rlanÄ±yordu. Kaan ve Elif, ustalarÄ±nÄ±n Ã¶ÄŸreteceÄŸi yeni bilgileri merakla bekliyorlardÄ±.
>
> Elara, "DÃ¼n 'ProsedÃ¼r TanÄ±mlama'nÄ±n karmaÅŸÄ±klÄ±ÄŸÄ± nasÄ±l yÃ¶nettiÄŸini ve soyutlamanÄ±n (`abstraction`) gÃ¼cÃ¼nÃ¼ konuÅŸmuÅŸtuk," diye sÃ¶ze baÅŸladÄ±. "BugÃ¼n ise bu prosedÃ¼rleri nasÄ±l inÅŸa ettiÄŸimize, yani kullandÄ±ÄŸÄ±mÄ±z dilin bize sunduÄŸu temel yapÄ±taÅŸlarÄ±na ve bunlarÄ± nasÄ±l bir araya getirdiÄŸimize daha yakÄ±ndan bakacaÄŸÄ±z."
>
> > <span style="color:red;">â‘ </span>
> > > [!TIP]
> > > `Tool: Procedure Definition` {requires} `Tool: Primitive Elements`
>
> Elara, Ã¶nlerindeki kumlara basit bir daire Ã§izdi. "Her bÃ¼yÃ¼k yapÄ±nÄ±n temelinde olduÄŸu gibi, prosedÃ¼r tanÄ±mlamanÄ±n da en basit, en temel yapÄ±taÅŸlarÄ±na ihtiyacÄ± vardÄ±r. Bunlar, programlama dilimizin bize sunduÄŸu 'Ä°lkel Elemanlar'dÄ±r (`Primitive Elements`). **TÄ±pkÄ± bir heykeltÄ±raÅŸÄ±n eserine baÅŸlarken kullandÄ±ÄŸÄ± ham kil veya mermer bloku gibi.** Bu ilkel elemanlar iki tÃ¼rlÃ¼dÃ¼r: Birincisi, sayÄ±lar gibi Ã¼zerinde iÅŸlem yapacaÄŸÄ±mÄ±z 'veriler' (`data`), ikincisi ise toplama, Ã§arpma gibi en temel 'iÅŸlemler'dir (`primitive procedures`). Bunlar, dilin bize doÄŸrudan sunduÄŸu, daha fazla parÃ§alanamayan en kÃ¼Ã§Ã¼k anlamlÄ± birimlerdir. Bir prosedÃ¼r, bu temel elemanlar Ã¼zerine inÅŸa edilir, onlarla ÅŸekillenir."
>
> Kaan, "Yani Usta," dedi, "bir yemek yaparken kullanacaÄŸÄ±mÄ±z un, su, tuz gibi temel malzemeler mi bunlar?" Elara gÃ¼lÃ¼msedi, "Tam da Ã¶yle Kaan. Bu temel malzemeler olmadan hiÃ§bir yemek yapamayÄ±z, deÄŸil mi? Ä°ÅŸte Ä°lkel Elemanlar da bÃ¶yledir."
>
> > <span style="color:red;">â‘¡</span>
> > > [!TIP]
> > > `Tool: Primitive Elements` {are_used_by} `Tool: Means of Combination`
>
> Elif merakla sordu, "Peki Usta, bu ilkel elemanlarÄ± elimize aldÄ±k. Sonra ne yapacaÄŸÄ±z? OnlarÄ± nasÄ±l daha karmaÅŸÄ±k yapÄ±lara dÃ¶nÃ¼ÅŸtÃ¼receÄŸiz?"
>
> Elara, "GÃ¼zel bir soru Elif," dedi. "Ä°lkel elemanlar tek baÅŸlarÄ±na Ã§ok gÃ¼Ã§lÃ¼ olmayabilirler, ancak 'BirleÅŸtirme YÃ¶ntemleri' (`Means of Combination`) sayesinde onlarÄ± bir araya getirerek karmaÅŸÄ±k ve anlamlÄ± yapÄ±lar oluÅŸturabiliriz. Dilimiz, bu basit parÃ§alarÄ± alÄ±p daha bÃ¼yÃ¼k bileÅŸik Ã¶ÄŸeler (`compound elements`) inÅŸa etmek iÃ§in mekanizmalar sunar. **TÄ±pkÄ± bir duvar ustasÄ±nÄ±n tek tek tuÄŸlalarÄ± harÃ§la birleÅŸtirerek saÄŸlam bir duvar Ã¶rmesi gibi.** Ä°lkel elemanlar, bu birleÅŸtirme yÃ¶ntemleri aracÄ±lÄ±ÄŸÄ±yla kullanÄ±lÄ±r ve daha bÃ¼yÃ¼k anlamlar kazanÄ±r."
>
> > <span style="color:red;">â‘¢</span>
> > > [!TIP]
> > > `Tool: Means of Combination` {uses} `Prefix Notation`
>
> Kaan, "Bu birleÅŸtirme yÃ¶ntemleri nasÄ±l iÅŸliyor, Usta? Mesela, toplama iÅŸlemi yaparken sayÄ±larÄ± nasÄ±l bir araya getiriyoruz?" diye sordu.
>
> Elara, "Bizim kullandÄ±ÄŸÄ±mÄ±z Scheme dilinde," diye aÃ§Ä±kladÄ±, "birleÅŸtirme genellikle parantezlerle Ã§evrelenmiÅŸ listeler, yani 'kombinasyonlar' (`combinations`) ÅŸeklinde olur. Bu kombinasyonlar, bir prosedÃ¼rÃ¼n uygulanmasÄ±nÄ± temsil eder. Ve burada Ã¶nemli bir nokta var: Biz iÅŸlemleri ifade ederken 'Ã–n Ek GÃ¶sterimi'ni (`Prefix Notation`) kullanÄ±rÄ±z. Yani, yapÄ±lacak iÅŸlemi (operatÃ¶rÃ¼) her zaman en baÅŸa, sol tarafa yazarÄ±z, ardÄ±ndan da Ã¼zerinde iÅŸlem yapÄ±lacak deÄŸerleri (operanlarÄ±) sÄ±ralarÄ±z. Ã–rneÄŸin, `(+ 2 3)` gibi. **Bu, sanki bir emir verir gibi; Ã¶nce ne yapÄ±lacaÄŸÄ±nÄ± sÃ¶ylersin, sonra da kimlere veya nelere yapÄ±lacaÄŸÄ±nÄ±.** Bu gÃ¶sterim, birden fazla argÃ¼man alan veya iÃ§ iÃ§e geÃ§miÅŸ karmaÅŸÄ±k ifadelerde bÃ¼yÃ¼k kolaylÄ±k saÄŸlar."
>
> > <span style="color:red;">â‘£</span>
> > > [!TIP]
> > > `Tool: Means of Combination` {requires} `Tool: Evaluation Model`
>
> Elif, "AnlÄ±yorum Usta," dedi. "OperatÃ¶rÃ¼ baÅŸa yazÄ±yoruz ve operanlarÄ± sÄ±ralÄ±yoruz. Peki, bilgisayar bu yazdÄ±ÄŸÄ±mÄ±z birleÅŸik ifadeyi nasÄ±l anlÄ±yor da doÄŸru sonucu Ã¼retiyor? Ã–rneÄŸin, `(* (+ 2 3) 4)` yazdÄ±ÄŸÄ±mÄ±zda, Ã¶nce toplamayÄ± sonra Ã§arpmayÄ± yapacaÄŸÄ±nÄ± nereden biliyor?"
>
> Elara, "Ä°ÅŸte burada 'DeÄŸerlendirme Modeli' (`Evaluation Model`) devreye girer, Elif," diye yanÄ±tladÄ±. "BirleÅŸtirme yÃ¶ntemlerinin doÄŸru Ã§alÄ±ÅŸabilmesi iÃ§in, dilin bu birleÅŸik ifadeleri nasÄ±l yorumlayacaÄŸÄ±nÄ± ve iÅŸleme alacaÄŸÄ±nÄ± tanÄ±mlayan kurallara ihtiyacÄ± vardÄ±r. Bu model, **bir aÅŸÃ§Ä±nÄ±n elindeki tarife adÄ±m adÄ±m uymasÄ± gibi,** ifadenin hangi parÃ§asÄ±nÄ±n Ã¶nce deÄŸerlendirileceÄŸini, operatÃ¶rÃ¼n operanlara nasÄ±l uygulanacaÄŸÄ±nÄ± belirler. Genellikle, en iÃ§teki parantezlerden baÅŸlanarak alt ifadeler deÄŸerlendirilir ve elde edilen deÄŸerler bir Ã¼st seviyedeki iÅŸlemlerde kullanÄ±lÄ±r. Bu sistematik deÄŸerlendirme olmadan, birleÅŸtirme yÃ¶ntemlerimiz anlamsÄ±z kalÄ±rdÄ±."
>
> > <span style="color:red;">â‘¤</span>
> > > [!TIP]
> > > `Tool: Procedure Definition` {requires} `Tool: Means of Abstraction (Naming)`
>
> "ProsedÃ¼rleri tanÄ±mlarken," diye devam etti Elara, "onlara bir kimlik vermemiz, onlarÄ± Ã§aÄŸÄ±rmak iÃ§in bir isme sahip olmamÄ±z gerekir. Ä°ÅŸte bu noktada SoyutlamanÄ±n bir baÅŸka aracÄ± olan 'Ä°simlendirme' (`Naming`) yani 'Soyutlama YÃ¶ntemleri' (`Means of Abstraction`) devreye girer. Dilimizde `define` komutunu kullanarak bir prosedÃ¼re veya bir deÄŸere bir isim atarÄ±z. Bu, karmaÅŸÄ±k bir iÅŸlemi veya veriyi basit bir isimle temsil etmemizi saÄŸlar. `(define (kare x) (* x x))` dediÄŸimizde, `kare` artÄ±k o Ã§arpma iÅŸleminin bir adÄ± olur. **Bu, keÅŸfettiÄŸimiz yeni bir yÄ±ldÄ±za isim vermek gibidir; artÄ±k ona parmakla gÃ¶stermek yerine ismiyle hitap edebiliriz.** Bu isimlendirme, aynÄ± zamanda soyutlama (`abstraction`) prensibini de destekler, Ã§Ã¼nkÃ¼ detaylarÄ± (`implementation details`) bir isim altÄ±nda gizleyerek (`hiding details`) sadece ne yapÄ±ldÄ±ÄŸÄ±na odaklanmamÄ±zÄ± saÄŸlar."
>
> > <span style="color:red;">â‘¥</span>
> > > [!TIP]
> > > `Tool: Means of Abstraction (Naming)` {supports} `Principle: Abstraction`
>
> Kaan heyecanla, "Yani Usta, `define` ile bir prosedÃ¼re isim verdiÄŸimizde, aslÄ±nda onun nasÄ±l Ã§alÄ±ÅŸtÄ±ÄŸÄ±nÄ±n ayrÄ±ntÄ±larÄ±nÄ± bir kenara bÄ±rakÄ±p, sadece o ismin temsil ettiÄŸi genel fikre odaklanabiliyoruz, Ã¶yle mi?"
>
> Elara baÅŸÄ±yla onayladÄ±. "Kesinlikle Kaan. Ä°simlendirme, soyutlama prensibini (`Principle: Abstraction`) doÄŸrudan destekler. KarmaÅŸÄ±k bir iÅŸlemi veya bir dizi adÄ±mÄ± alÄ±p ona `kare_al` (`square`) veya `kÃ¶k_bul` (`sqrt`) gibi bir isim verdiÄŸimizde, o iÅŸlemin iÃ§ yapÄ±sÄ±nÄ± dÃ¼ÅŸÃ¼nmek zorunda kalmayÄ±z. O isim artÄ±k bizim iÃ§in bir 'kara kutu' (`black box`) haline gelir. Bu, zihinsel yÃ¼kÃ¼mÃ¼zÃ¼ azaltÄ±r ve daha bÃ¼yÃ¼k problemleri daha kÃ¼Ã§Ã¼k, yÃ¶netilebilir ve isimlendirilmiÅŸ parÃ§alarla (`coherent units`) Ã§Ã¶zmemize olanak tanÄ±r. Tekrar tekrar aynÄ± kod bloklarÄ±nÄ± yazmak yerine, tanÄ±mladÄ±ÄŸÄ±mÄ±z ismi kullanarak ortak kalÄ±plarÄ± (`common patterns`) yeniden kullanabiliriz. Ä°ÅŸte bu, soyutlamanÄ±n gÃ¼cÃ¼dÃ¼r: **Bir marangozun, her seferinde Ã¶lÃ§Ã¼p kesmek yerine, standart boyutlarda hazÄ±rladÄ±ÄŸÄ± bir kiriÅŸe 'ana taÅŸÄ±yÄ±cÄ±' adÄ±nÄ± verip gerektiÄŸinde onu kullanmasÄ± gibi.**"
>
> > <span style="color:red;">â‘¦</span>
> > > [!TIP]
> > > `Tool: Means of Abstraction (Naming)` {requires} `Environment`
>
> Elif kaÅŸlarÄ±nÄ± Ã§attÄ±. "Usta, `define` ile bir ÅŸeye isim verdiÄŸimizde, Ã¶rneÄŸin `(define pi 3.14159)` dediÄŸimizde, bilgisayar bu `pi` isminin `3.14159` deÄŸerine karÅŸÄ±lÄ±k geldiÄŸini nasÄ±l hatÄ±rlÄ±yor? Bu bilgi nerede saklanÄ±yor?"
>
> Elara gÃ¼lÃ¼msedi. "Ã‡ok yerinde bir soru Elif. Ä°simlendirme aracÄ±mÄ±zÄ±n Ã§alÄ±ÅŸabilmesi iÃ§in, bu isim-deÄŸer eÅŸleÅŸmelerinin saklandÄ±ÄŸÄ± bir yere ihtiyacÄ±mÄ±z var. Bu yere 'Ortam' (`Environment`) diyoruz. **OrtamÄ±, her kelimenin anlamÄ±nÄ±n yazÄ±lÄ± olduÄŸu dev bir sÃ¶zlÃ¼k gibi dÃ¼ÅŸÃ¼nebilirsin.** `define` kullandÄ±ÄŸÄ±mÄ±zda, bu sÃ¶zlÃ¼ÄŸe yeni bir kelime (isim) ve onun anlamÄ±nÄ± (deÄŸerini) eklemiÅŸ oluruz. ProgramÄ±mÄ±z iÃ§inde bir isim kullandÄ±ÄŸÄ±mÄ±zda, yorumlayÄ±cÄ± bu sÃ¶zlÃ¼ÄŸe bakar ve o ismin karÅŸÄ±lÄ±k geldiÄŸi deÄŸeri bulur. Bu ortam olmadan, verdiÄŸimiz isimler havada kalÄ±r, bir anlam ifade etmezdi. ProgramlarÄ±mÄ±z geliÅŸtikÃ§e ve iÃ§ iÃ§e yapÄ±lar kurdukÃ§a, bu ortam kavramÄ±nÄ±n daha da karmaÅŸÄ±klaÅŸtÄ±ÄŸÄ±nÄ± ama temel prensibinin aynÄ± kaldÄ±ÄŸÄ±nÄ± gÃ¶receÄŸiz."
>
> Kaan ve Elif, programlamanÄ±n temel yapÄ±taÅŸlarÄ±nÄ±n, bu taÅŸlarÄ± birleÅŸtirme sanatÄ±nÄ±n ve onlara anlamlÄ± isimler vererek soyutlamalar (`abstractions`) oluÅŸturmanÄ±n ne kadar incelikli ama bir o kadar da gÃ¼Ã§lÃ¼ olduÄŸunu bir kez daha idrak etmiÅŸlerdi. Elara'nÄ±n metaforlarÄ±, bu soyut kavramlarÄ± zihinlerinde somutlaÅŸtÄ±rmalarÄ±na yardÄ±mcÄ± olmuÅŸtu. Kod yazmanÄ±n sadece komutlar dizmek deÄŸil, aynÄ± zamanda anlamlÄ± ve yÃ¶netilebilir dÃ¼nyalar inÅŸa etmek olduÄŸunu daha iyi anlÄ±yorlardÄ±.
>
> Elara, "UnutmayÄ±n Ã§ocuklar," dedi. "Ä°lkel elemanlar harflerse, birleÅŸtirme yÃ¶ntemleri kelimeleri, soyutlama yÃ¶ntemleri ise cÃ¼mleleri ve hikayeleri oluÅŸturmamÄ±zÄ± saÄŸlar. Her bir araÃ§, bir diÄŸeriyle uyum iÃ§inde Ã§alÄ±ÅŸarak dÃ¼ÅŸÃ¼ncelerimizi koda dÃ¶kmemize imkan tanÄ±r."
>
> Ã‡Ä±raklar, ustalarÄ±nÄ±n bilgeliÄŸi karÅŸÄ±sÄ±nda bir kez daha saygÄ±yla eÄŸildiler. Ã–ÄŸrenecekleri daha Ã§ok ÅŸey vardÄ± ama artÄ±k yollarÄ± daha aydÄ±nlÄ±ktÄ±.
>
> ```
{ #dd0702}


---

## ğŸ”‘ Key Points
- 
## â“ Questions
- 
## ğŸ“¦ Resources
- PODCAST (IN TURKISH) :![[Dil ElemanlarÄ±nÄ±n Hikayesi.wav]]
- PODCAST (IN ENGLISH):![[Dil ElemanlarÄ±nÄ±n Hikayesi-(InEnglish).wav]]
- MIND MAP IN PNG: [[5.LangElems 1.png]]
## ğŸ¯ Actions
- [ ] 
- [ ] 
- [ ] 
- [ ] 
- [ ] 