---
{"dg-publish":true,"permalink":"/20-work-spaces/computer-science/programming/scheme/sicp/detailed/chapter-i/codebox/6-exponentiation/"}
---



up:: 
tags:: 



# 6. Exponentiation

## Fast Exponentiation (Recursive)

- $b^n$ = b * $b^{n-1}$ when n is odd
- $b^n$ = $(b^{(n/2)})^2$ when n is even

```scheme
#lang racket


;; 1 : Signature-Purpose - Stub
; Signature : Natural Natural -> Natural
; Purpose : takes a base (b) and a power (n), and calculates (b^n)
; Stub
;(define (expt b n) 1)

;; 3. Template
#;
(define (expt b n)
  (... b
   ... n))

;; 5. Code the body
(define (expt b n)
  (define (square x) (* x x))
  (cond [(= b 0) 0]
        [(= b 1) 1]
        [(= n 0) 1]
        [(= n 1) b]
        [else (if (even? n)
                  (square (expt b (/ n 2)))
                  (* b (expt b (- n 1))))]))

;2. Examples
(require rackunit)
(require rackunit/text-ui)


(define expt-tests
  (test-suite
   "Tests for expt function"
   ;;
   (test-case
    "0 power test"
    (check-equal? (expt 2 0) 1)
    (check-equal? (expt 100 0) 1))

   ;; 
   (test-case
    "1 power test"
    (check-equal? (expt 2 1) 2)
    (check-equal? (expt 100 1) 100))

   ;;
   (test-case
    "0 base"
    (check-equal? (expt 0 100) 0)
    (check-equal? (expt 0 200) 0))

   ;;
   (test-case
    "1 base"
    (check-equal? (expt 1 100) 1)
    (check-equal? (expt 1 200) 1))

   ;;
   (test-case
    "regular test"
    (check-equal? (expt 2 11) 2048)
    (check-equal? (expt 3 4) 81))))


(run-tests expt-tests)
```

$2^5$ -> $2^4$ * 2 ->
### Trace

```scss
>(expt 2 33)
> (expt 2 32)
> >(expt 2 16)
> > (expt 2 8)
> > >(expt 2 4)
> > > (expt 2 2)
> > > >(expt 2 1)
< < < <2
< < < 4
< < <16
< < 256
< <65536
< 4294967296
<8589934592
8589934592
```

### Explanation 

1. **Process Type:**Â ThisÂ `expt`Â function generates aÂ **`Linear Recursive Process`Â ([!TIP] â‘ Â `Analysis: Processes Generated`Â {details}Â `Linear Recursive Process`)**.
    
    - Although the problem sizeÂ `n`Â is reduced either by division (for evenÂ `n`) or subtraction (for oddÂ `n`), each recursive step makes onlyÂ _one_Â call toÂ `expt`.
      
    - Crucially, there's aÂ **`deferred operation`**Â associated with each recursive call: eitherÂ `square`Â (ifÂ `n`Â was even) or multiplication byÂ `b`Â (ifÂ `n`Â was odd). 
    - The process builds up a chain of these deferred operations that are executed as the recursion unwinds. This "waiting chain" is characteristic of a linear recursive process.
    - 
2. **Space Usage:**Â This process exhibitsÂ **`Growing Space Usage (Often Linear)`Â ([!TIP] â‘¡Â `Linear Recursive Process`Â {has_characteristic}Â `Growing Space Usage (Often Linear)`)**.
    
    - Each deferred operation needs to be remembered (typically on the call stack). 
    - The number of such operations corresponds to the depth of the recursion.
    - For this "exponentiation by squaring" algorithm, the depth of recursion is logarithmic with respect toÂ `n`Â (i.e., O(log n)). 
    - So, while space usage grows, it grows very slowly (logarithmically withÂ `n`), making it efficient. 
	    - The number of deferred operations is logarithmic in terms of the input.

## Slow Expt (Simple Iterative)

```scheme
(define (expt b n)
  (define (expt-iter rsf p)
    (cond [(= p 1) rsf]
          [else (expt-iter (* rsf b) (- p 1))]))
  (cond [(= b 0) 0]
        [(= b 1) 1]
        [(= n 0) 1]
        [(= n 1) b]
        [else (expt-iter b n)]))
```

### Trace
```scss
>(expt-iter 2 33)
>(expt-iter 4 32)
>(expt-iter 8 31)
>(expt-iter 16 30)
>(expt-iter 32 29)
>(expt-iter 64 28)
>(expt-iter 128 27)
>(expt-iter 256 26)
>(expt-iter 512 25)
>(expt-iter 1024 24)
>(expt-iter 2048 23)
>(expt-iter 4096 22)
>(expt-iter 8192 21)
>(expt-iter 16384 20)
>(expt-iter 32768 19)
>(expt-iter 65536 18)
>(expt-iter 131072 17)
>(expt-iter 262144 16)
>(expt-iter 524288 15)
>(expt-iter 1048576 14)
>(expt-iter 2097152 13)
>(expt-iter 4194304 12)
>(expt-iter 8388608 11)
>(expt-iter 16777216 10)
>(expt-iter 33554432 9)
>(expt-iter 67108864 8)
>(expt-iter 134217728 7)
>(expt-iter 268435456 6)
>(expt-iter 536870912 5)
>(expt-iter 1073741824 4)
>(expt-iter 2147483648 3)
>(expt-iter 4294967296 2)
>(expt-iter 8589934592 1)
<8589934592
8589934592
```

### Explanation
- Pay attention this is tail recursive, so it will generate an iterative shape.

1. **Process Type:**Â ThisÂ `expt`Â implementation, specifically through itsÂ `expt-iter`Â helper, generates aÂ **`Linear Iterative Process`Â ([!TIP] â‘¢Â `Analysis: Processes Generated`Â {details}Â `Linear Iterative Process`)**.
    
    - The state of the computation at each step ofÂ `expt-iter`Â is completely captured by the current values of its arguments,Â `rsf`Â andÂ `p`. There are no "deferred operations" building up that need to be resolved later. The calculation ofÂ `(* rsf b)`Â happensÂ _before_Â the next recursive call. This is exactly what Elara described for iterative processes:Â _"O anda Ã¶nemli olan sadece kilin mevcut ÅŸekli... tÃ¼m bilgi, o anki durumun kendisindedir ve bir sonraki dokunuÅŸla gÃ¼ncellenir."_Â (What matters at that moment is just the current shape of the clay... all information is in the current state itself and is updated with the next touch.)
      
2. **Space Usage:**Â This process exhibitsÂ **`Constant Space Usage`Â ([!TIP] â‘£Â `Linear Iterative Process`{has_characteristic}Â `Constant Space Usage`)**.
    
    - Because there's no accumulation of deferred operations, the amount of memory required forÂ `expt-iter`Â to run does not grow withÂ `n`Â (the exponent). The system only needs enough space for the currentÂ `rsf`,Â `p`, and the fixed code. This fits Elara's marathon runner analogy:Â _"yanÄ±nda taÅŸÄ±masÄ± gereken bilgi yÃ¼kÃ¼ yarÄ±ÅŸÄ±n uzunluÄŸuna gÃ¶re artmaz."_Â (The information load they need to carry doesn't increase with the length of the race.)
      
3. **Syntax vs. Process & Tail Recursion:**Â This is a prime example whereÂ **`Recursive Procedure Syntax`{can_generate}Â `Iterative Process`Â {if}Â `Tail-Recursive Implementation exists`Â ([!TIP] â‘¥)**.
    
    - TheÂ `expt-iter`Â function is syntactically recursive (it calls itself).
    - However, the recursive callÂ `(expt-iter (* rsf b) (- p 1))`Â is theÂ _very last_Â operation in itsÂ `else`Â branch. There's nothing more to do after this call returns; its result is the result of the current call. This makesÂ `expt-iter`Â aÂ **`Tail-Recursive Implementation`**.
    - Racket, like many Scheme implementations, performs tail-call optimization. This means it can execute this tail-recursive function using an iterative process, effectively reusing the same memory space (stack frame) for each step, thus achieving constant space. Elara's analogy of the artisan clearing the table and reusing it for the next step fits perfectly:Â _"Yeni bir masa aÃ§masÄ±na (yeni bir bellek alanÄ± ayÄ±rmasÄ±na) gerek kalmaz..."_Â (There's no need to open a new desk (allocate new memory space)...)
- Takes $\Theta (n)$ time because it does n multiplications

## Fast Expt (Iterative)

### Code
```scheme
(define (expt b n)
  (define (expt-iter current-base current-exponent rsf)
    (cond [(= current-exponent 0) rsf]
          [(odd? current-exponent) (expt-iter current-base (- current-exponent 1) (* current-base rsf))]
          [else (expt-iter (square current-base) (/ current-exponent 2) rsf)]))
  (trace expt-iter)
  (cond [(= b 0) 0]
        [(= b 1) 1]
        [(= n 0) 1]
        [(= n 1) b]
        [else (expt-iter b n 1)]))
```

### Trace

```scheme
>(expt-iter 2 33 1)
>(expt-iter 2 32 2)
>(expt-iter 4 16 2)
>(expt-iter 16 8 2)
>(expt-iter 256 4 2)
>(expt-iter 65536 2 2)
>(expt-iter 4294967296 1 2)
>(expt-iter 4294967296 0 8589934592)
<8589934592
8589934592
```

### Explanation

- Takes $\Theta (log n)$ time, and still constant space

---

## ðŸ”‘ Key Points
- 
## â“ Questions
- 
## ðŸ“¦ Resources
- 
## ðŸŽ¯ Actions
- [ ] 
- [ ] 
- [ ] 
- [ ] 
- [ ] 