---
{"dg-publish":true,"permalink":"/20-work-spaces/computer-science/programming/scheme/sicp/detailed/chapter-i/codebox/10-half-interval-method/"}
---



up:: 
tags:: 



# 10. Half-interval Method

## Code 

```scheme
#lang racket

(define (half-interval f a b)
  (define tolerance 0.00001)

  (define (average x y) (/ (+ x y) 2.0))
  
  ;checks whether 2 points are close enough
  (define (close-enough? v1 v2)
    (< (abs  (- v1 v2)) tolerance))
  ;calculates the mid point
  (define (search f neg-pt pos-pt)
    (if (close-enough? neg-pt pos-pt)
        neg-pt
        (let ([midpt (average neg-pt pos-pt)])
          (if (positive? (f midpt))
              (search f neg-pt midpt)
              (search f midpt pos-pt)))))

  (let ([fa (f a)]
        [fb (f b)])
    (cond [(and (positive? fa)
                (negative? fb)) (search f b a)]
          [(and (positive? fb)
                (negative? fa)) (search f a b)]
          [else (error 'half-interval "can't have both negative or positive")])))


(half-interval (lambda (x) (- (* x x x) 27)) 2 100) 
; expecting 3 but we receive 2.999999523162842

```

## Explanation

Let's break down the code and relate it to the iterative algorithm steps:

1. **Specifications**:
    
    - **Problem**: Find a root of the functionÂ `f`Â in the intervalÂ `[a, b]`.
    - **Preconditions**:Â 
	    - `f`Â is a continuous function, andÂ `f(a)`Â andÂ `f(b)`Â must have opposite signs. 
	    - The initial intervalÂ `[a,b]`Â must bracket a root.
    - **Postconditions**: 
	    - Returns an approximation of the rootÂ `x`Â such thatÂ `f(x)`Â is close to 0, andÂ `x`Â is within the intervalÂ `[a,b]`. 
	    - The approximation is withinÂ `tolerance`Â of the true root, or more precisely, the interval containing the root has a width less thanÂ `tolerance`.
      
2. **Basic Steps**:
    
    - Calculate the midpoint of the current interval.
    - Evaluate the functionÂ `f`Â at the midpoint.
    - Reduce the interval to the half that must contain the root.
    - Repeat until the interval is sufficiently small.
      
3. **Measure of Progress**:
    
    - The width of the intervalÂ `[neg-pt, pos-pt]`. With each iteration, this width is halved.
      
4. **The Loop Invariant (Implicit in theÂ `search`Â recursion)**:
    
    - At the beginning of each call toÂ `search f neg-pt pos-pt`:
        1. `f(neg-pt)`Â andÂ `f(pos-pt)`Â have opposite signs (or one is zero).
        2. The root ofÂ `f`Â lies within the intervalÂ `[neg-pt, pos-pt]`.
           
5. **Main Steps (within theÂ `search`Â function)**:
    
    - `midpt = (average neg-pt pos-pt)`: Calculate the midpoint.
    - `test-value = (f midpt)`: EvaluateÂ `f`Â at the midpoint.
    - TheÂ `if (positive? (f midpt))`Â (orÂ `(negative? (f midpt))`Â depending on howÂ `neg-pt`Â andÂ `pos-pt`Â are ordered relative to their function values) statement decides which half of the interval to recurse on:
        - IfÂ `(f midpt)`Â has the same sign asÂ `(f pos-pt)`, the new interval becomesÂ `[neg-pt, midpt]`. (In the code, ifÂ `(f midpt)`Â is positive, it meansÂ `midpt`Â becomes the newÂ `pos-pt`Â for the next call, assumingÂ `neg-pt`Â was indeed negative).
        - IfÂ `(f midpt)`Â has the same sign asÂ `(f neg-pt)`, the new interval becomesÂ `[midpt, pos-pt]`. (In the code, ifÂ `(f midpt)`Â is negative or zero, it meansÂ `midpt`Â becomes the newÂ `neg-pt`).
    - The provided code simplifies this by ensuringÂ `neg-pt`Â is whereÂ `f`Â is negative (orÂ `pos-pt`Â whereÂ `f`Â is positive initially). Then:
        - IfÂ `(f midpt)`Â is positive, the root is inÂ `[neg-pt, midpt]`, soÂ `(search f neg-pt midpt)`.
        - IfÂ `(f midpt)`Â is negative (or zero), the root is inÂ `[midpt, pos-pt]`, soÂ `(search f midpt pos-pt)`.
          
6. **Make Progress**:
    
    - Each recursive call toÂ `search`Â halves the intervalÂ `(abs (- pos-pt neg-pt))`. This ensures the algorithm converges.
      
7. **Maintain Loop Invariant**:
    
    - The logic withinÂ `search`Â ensures that the new smaller intervalÂ `[new-neg-pt, new-pos-pt]`Â still brackets the root because of the Intermediate Value Theorem. IfÂ `f(midpt)`Â has the opposite sign toÂ `f(neg-pt)`, the root is inÂ `[neg-pt, midpt]`. IfÂ `f(midpt)`Â has the opposite sign toÂ `f(pos-pt)`, the root is inÂ `[midpt, pos-pt]`. The code correctly updatesÂ `neg-pt`Â orÂ `pos-pt`Â toÂ `midpt`Â to maintain this.
      
8. **Establishing the Loop Invariant**:
    
    - The initialÂ `let`Â block inÂ `half-interval`Â evaluatesÂ `fa = (f a)`Â andÂ `fb = (f b)`.
    - TheÂ `cond`Â statement checks ifÂ `fa`Â andÂ `fb`Â have opposite signs.
        - `[(and (positive? fa) (negative? fb)) (search f b a)]`: Here,Â `f(b)`Â is negative andÂ `f(a)`Â is positive. SoÂ `b`Â becomesÂ `neg-pt`Â andÂ `a`Â becomesÂ `pos-pt`Â for the first call toÂ `search`.
        - `[(and (positive? fb) (negative? fa)) (search f a b)]`: Here,Â `f(a)`Â is negative andÂ `f(b)`Â is positive. SoÂ `a`Â becomesÂ `neg-pt`Â andÂ `b`Â becomesÂ `pos-pt`.
    - This setup ensures that the invariant (`f(neg-pt)`Â andÂ `f(pos-pt)`Â have opposite signs) holds for the first call toÂ `search`.
    - If they have the same sign, an error is raised, satisfying the precondition check.
      
9. **Exit Condition**:
    
    - `(close-enough? neg-pt pos-pt)`, which meansÂ `(< (abs (- neg-pt pos-pt)) tolerance)`. The iteration stops when the interval width is smaller thanÂ `tolerance`.
10. **Ending**:
    
    - When the exit condition is met, the function returnsÂ `neg-pt`Â (orÂ `pos-pt`, as they are very close). This value is an approximation of the root.
      
11. **Termination and Running Time**:
    The algorithm terminates because the interval width decreases by half in each step. If the initial interval width is $W_0 = |b-a|$, after $k$ iterations, the width is $W_k = \frac{W_0}{2^k}$. The algorithm stops when $W_k < \text{tolerance}$. So, we need: $$ \frac{W_0}{2^k} < \text{tolerance} $$ This implies: $$ 2^k > \frac{W_0}{\text{tolerance}} $$ Taking $\log_2$ of both sides gives: $$ k > \log_2\left(\frac{W_0}{\text{tolerance}}\right) $$ The number of iterations is logarithmic with respect to the initial interval width ($W_0$) and inversely related to the logarithm of the tolerance.
    
12. **Special Cases**:
    
    - The code explicitly handles the case whereÂ `f(a)`Â andÂ `f(b)`Â do not have opposite signs by raising an error.
    - IfÂ `f(midpt)`Â happens to be exactly zero, the algorithm will continue to narrow the interval until theÂ `close-enough?`Â condition is met. TheÂ `midpt`Â will be part of the new interval.
---

## ğŸ”‘ Key Points
- 
## â“ Questions
- 
## ğŸ“¦ Resources
- 
## ğŸ¯ Actions
- [ ] 
- [ ] 
- [ ] 
- [ ] 
- [ ] 