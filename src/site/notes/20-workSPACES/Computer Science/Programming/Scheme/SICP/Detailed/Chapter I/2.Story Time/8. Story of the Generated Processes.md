---
{"dg-publish":true,"permalink":"/20-work-spaces/computer-science/programming/scheme/sicp/detailed/chapter-i/2-story-time/8-story-of-the-generated-processes/"}
---


up:: 
tags:: 

# 8. Story of the Generated Processes

> [!MIND-MAP STORY]
>
> ## Bilge Kod UstasÄ± Elara ve SÃ¼reÃ§lerin DansÄ±
>
> Elara, Ã§Ä±raklarÄ± Kaan ve Elif'i bu kez akan bir nehrin kÄ±yÄ±sÄ±na gÃ¶tÃ¼rmÃ¼ÅŸtÃ¼. Suyun sÃ¼rekli deÄŸiÅŸen ama bir yandan da belirli kalÄ±plar izleyen akÄ±ÅŸÄ±nÄ± izliyorlardÄ±.
>
> "ProsedÃ¼rlerle nasÄ±l soyutlamalar inÅŸa ettiÄŸimizi ve bu soyutlamalarÄ±n nasÄ±l 'kara kutular' gibi davranabildiÄŸini konuÅŸtuk," diye sÃ¶ze baÅŸladÄ± Elara. "BugÃ¼n ise bu prosedÃ¼rlerin can verdiÄŸi 'sÃ¼reÃ§lerin' (`processes`) kendilerine, yani bilgisayarÄ±n iÃ§inde adÄ±m adÄ±m nasÄ±l bir 'yaÅŸam' sÃ¼rdÃ¼klerine, nasÄ±l ÅŸekiller ve desenler oluÅŸturduklarÄ±na bakacaÄŸÄ±z. Bir prosedÃ¼r, bir sÃ¼recin yerel evrimi iÃ§in bir ÅŸablondur (`pattern for the local evolution`). Ancak biz, bu yerel adÄ±mlardan doÄŸan sÃ¼recin genel, kÃ¼resel davranÄ±ÅŸÄ±nÄ± (`global behavior`) anlamak isteriz."
>
> Elif, "Yani Usta," dedi, "yazdÄ±ÄŸÄ±mÄ±z her prosedÃ¼r, bilgisayarÄ±n iÃ§inde farklÄ± bir 'dans' mÄ± sergiliyor?"
>
> Elara gÃ¼lÃ¼msedi. "GÃ¼zel bir benzetme, Elif. Evet, her prosedÃ¼rÃ¼n oluÅŸturduÄŸu sÃ¼recin kendine has bir akÄ±ÅŸÄ±, bir 'ÅŸekli' (`shape`) vardÄ±r. Bu ÅŸekilleri analiz etmek (`Analysis: Processes Generated`), programlarÄ±mÄ±zÄ±n ne kadar zaman ve ne kadar bellek (alan) tÃ¼keteceÄŸini anlamamÄ±za yardÄ±mcÄ± olur. TÄ±pkÄ± bu nehrin bazen dar bir geÃ§itte hÄ±zla akmasÄ±, bazen de geniÅŸ bir yatakta yavaÅŸÃ§a yayÄ±lmasÄ± gibi."
>
> > <span style="color:red;">â‘ </span>
> > > [!TIP]
> > > `Analysis: Processes Generated` {details} `Linear Recursive Process`
>
>> Elara eline bir dal parÃ§asÄ± aldÄ± ve kumun Ã¼zerine bir dizi iÃ§ iÃ§e geÃ§miÅŸ halka Ã§izmeye baÅŸladÄ±, her yeni halka bir Ã¶ncekinden biraz daha kÃ¼Ã§Ã¼ktÃ¼ ve merkeze doÄŸru ilerliyordu. "BazÄ± sÃ¼reÃ§ler, 'DoÄŸrusal Ã–zyinelemeli SÃ¼reÃ§' (`Linear Recursive Process`) dediÄŸimiz bir yapÄ± sergiler. Bu sÃ¼reÃ§lerde, bir iÅŸlemi tamamlamak iÃ§in, iÅŸlem kendi kendisinin biraz daha basit bir versiyonunu Ã§aÄŸÄ±rÄ±r ve bu Ã§aÄŸrÄ± bir zincir oluÅŸturur. Her Ã§aÄŸrÄ±, bir sonraki adÄ±ma geÃ§meden Ã¶nce bir 'ertelenmiÅŸ iÅŸlem' (`deferred operation`) biriktirir. **Sanki usta bir zanaatkarÄ±n, karmaÅŸÄ±k bir mÃ¼cevher yaparken, ana parÃ§ayÄ± monte etmeden Ã¶nce o parÃ§aya takÄ±lacak daha kÃ¼Ã§Ã¼k bir detayÄ±n hazÄ±rlanmasÄ±nÄ± beklemesi gibi. O kÃ¼Ã§Ã¼k detayÄ± yapacak Ã§Ä±rak da, kendi iÅŸi iÃ§in daha da kÃ¼Ã§Ã¼k bir parÃ§anÄ±n baÅŸka bir Ã§Ä±rak tarafÄ±ndan bitirilmesini bekler. Bu 'bekleme zinciri', en temel parÃ§a hazÄ±r olana kadar uzar gider. Her zanaatkar, bir sonraki parÃ§a gelene kadar kendi elindeki iÅŸi (ertelenmiÅŸ iÅŸlemi) yarÄ±m bÄ±rakÄ±p beklemek zorundadÄ±r. En basit parÃ§a tamamlandÄ±ÄŸÄ±nda, sonuÃ§lar zincir boyunca yukarÄ± doÄŸru, her zanaatkarÄ±n kendi ertelenmiÅŸ iÅŸini tamamlamasÄ±yla birleÅŸerek nihai mÃ¼cevhere ulaÅŸÄ±r.** Ã–rneÄŸin, faktÃ¶riyel hesabÄ±nÄ± `n * (n-1)!` ÅŸeklinde tanÄ±mlayan prosedÃ¼rÃ¼mÃ¼z bÃ¶yle bir sÃ¼reÃ§ oluÅŸturur. SÃ¼reÃ§, en iÃ§teki `1!` sonucunu bulana kadar geniÅŸler, sonra bu sonuÃ§lar dÄ±ÅŸa doÄŸru, biriken Ã§arpma iÅŸlemleriyle birleÅŸtirilerek daralÄ±r."
>
> > <span style="color:red;">â‘¡</span>
> > > [!TIP]
> > > `Linear Recursive Process` {has_characteristic} `Growing Space Usage (Often Linear)`
>
> Kaan, "Usta, bu ertelenmiÅŸ iÅŸlemler biriktikÃ§e, bilgisayarÄ±n bunlarÄ± hatÄ±rlamasÄ± gerekmez mi?" diye sordu.
>
> "Kesinlikle Kaan," diye yanÄ±tladÄ± Elara. "DoÄŸrusal Ã¶zyinelemeli bir sÃ¼recin Ã¶nemli bir Ã¶zelliÄŸi, bu ertelenmiÅŸ iÅŸlemler zincirini takip etmek iÃ§in artan miktarda bellek kullanmasÄ±dÄ±r. **Ne kadar Ã§ok iÃ§ iÃ§e Ã§aÄŸrÄ±, ne kadar uzun bir 'bekleyen iÅŸler' listesi varsa, o kadar Ã§ok 'not kaÄŸÄ±dÄ±na', yani belleÄŸe ihtiyaÃ§ duyulur.** FaktÃ¶riyel Ã¶rneÄŸinde, `n` bÃ¼yÃ¼dÃ¼kÃ§e, bekleyen Ã§arpmalarÄ±n sayÄ±sÄ± da artar, dolayÄ±sÄ±yla kullanÄ±lan bellek de genellikle `n` ile doÄŸru orantÄ±lÄ± olarak artar. Bu, sÃ¼recin 'bellek ayak izinin' (`space usage`) bÃ¼yÃ¼mesi anlamÄ±na gelir."
>
> > <span style="color:red;">â‘¢</span>
> > > [!TIP]
> > > `Analysis: Processes Generated` {details} `Linear Iterative Process`
>
> Elara bu kez kumun Ã¼zerine dÃ¼z bir Ã§izgi Ã§izdi ve Ã¼zerine eÅŸit aralÄ±klarla noktalar koydu. "Bir diÄŸer yaygÄ±n sÃ¼reÃ§ ÅŸekli ise 'DoÄŸrusal Yinelemeli SÃ¼reÃ§'tir (`Linear Iterative Process`). Bu sÃ¼reÃ§lerde, durum (`state`) sabit sayÄ±da deÄŸiÅŸkenle Ã¶zetlenebilir ve bu deÄŸiÅŸkenler her adÄ±mda belirli bir kurala gÃ¶re gÃ¼ncellenir. ErtelenmiÅŸ iÅŸlemler birikmez. **Sanki usta bir Ã§Ã¶mlekÃ§inin, dÃ¶nen bir tezgÃ¢h Ã¼zerinde bir kil yÄ±ÄŸÄ±nÄ±na ÅŸekil vermesi gibi. Ã‡Ã¶mlekÃ§i, her bir dÃ¶nÃ¼ÅŸte (her adÄ±mda) elleriyle (sabit kural) kile hafifÃ§e dokunarak onu biraz daha istediÄŸi forma (yeni duruma) yaklaÅŸtÄ±rÄ±r. O anda Ã¶nemli olan sadece kilin mevcut ÅŸekli, tezgÃ¢hÄ±n dÃ¶nÃ¼ÅŸ hÄ±zÄ± ve ellerinin o anki pozisyonudur (sabit sayÄ±daki durum deÄŸiÅŸkenleri). Bir Ã¶nceki dÃ¶nÃ¼ÅŸte kilin tam olarak nasÄ±l gÃ¶rÃ¼ndÃ¼ÄŸÃ¼nÃ¼ detaylÄ±ca hatÄ±rlamasÄ±na gerek yoktur; tÃ¼m bilgi, o anki durumun kendisindedir ve bir sonraki dokunuÅŸla gÃ¼ncellenir. Ã‡Ã¶mlekÃ§i, ne kadar bÃ¼yÃ¼k bir vazo yaparsa yapsÄ±n, o anda kullandÄ±ÄŸÄ± temel araÃ§lar ve dikkat ettiÄŸi deÄŸiÅŸkenler aynÄ± kalÄ±r.** FaktÃ¶riyel hesabÄ±nÄ± bir sayaÃ§ ve bir ara Ã§arpÄ±m deÄŸeri tutarak adÄ±m adÄ±m gÃ¼ncelleyen ikinci prosedÃ¼rÃ¼mÃ¼z (`fact-iter`) bu tÃ¼r bir sÃ¼reÃ§ oluÅŸturur. Her adÄ±mda, sayaÃ§ ve Ã§arpÄ±m gÃ¼ncellenir, ancak bekleyen bir iÅŸlem zinciri oluÅŸmaz."
>
> > <span style="color:red;">â‘£</span>
> > > [!TIP]
> > > `Linear Iterative Process` {has_characteristic} `Constant Space Usage`
>
> Elif, "Bu durumda, Usta," dedi, "bu yinelemeli sÃ¼reÃ§te bilgisayarÄ±n hatÄ±rlamasÄ± gereken ÅŸey sayÄ±sÄ± artmÄ±yor mu? Yani daha az bellek mi kullanÄ±yor?"
>
> "Tam Ã¼stÃ¼ne bastÄ±n, Elif," dedi Elara. "DoÄŸrusal yinelemeli bir sÃ¼recin en belirgin avantajÄ±, kullandÄ±ÄŸÄ± bellek miktarÄ±nÄ±n sabit olmasÄ±dÄ±r (`Constant Space Usage`). Problemin boyutu (`n` deÄŸeri) ne kadar bÃ¼yÃ¼k olursa olsun, sÃ¼recin o anki durumunu takip etmek iÃ§in gereken deÄŸiÅŸken sayÄ±sÄ± deÄŸiÅŸmez. **TÄ±pkÄ± bir maraton koÅŸucusunun, yarÄ±ÅŸÄ±n baÅŸÄ±nda da sonunda da sadece mevcut hÄ±zÄ±nÄ±, kalp atÄ±ÅŸÄ±nÄ± ve ne kadar mesafe kaldÄ±ÄŸÄ±nÄ± takip etmesi gibi; yanÄ±nda taÅŸÄ±masÄ± gereken bilgi yÃ¼kÃ¼ yarÄ±ÅŸÄ±n uzunluÄŸuna gÃ¶re artmaz.** Bu, Ã¶zellikle Ã§ok bÃ¼yÃ¼k girdilerle Ã§alÄ±ÅŸÄ±rken programlarÄ±mÄ±zÄ±n verimliliÄŸi iÃ§in hayati Ã¶nem taÅŸÄ±r."
>
> > <span style="color:red;">â‘¤</span>
> > > [!TIP]
> > > `Linear Recursive Process` {differs_from} `Linear Iterative Process`
>
> Kaan, "O zaman Usta, Ã¶zyinelemeli sÃ¼reÃ§ler bellek aÃ§Ä±sÄ±ndan daha masraflÄ± iken, yinelemeli sÃ¼reÃ§ler daha tutumlu. Bu, aralarÄ±ndaki temel fark mÄ±?" diye sordu.
>
> "Bellek kullanÄ±mÄ± (`space complexity`) aÃ§Ä±sÄ±ndan evet, bu Ã§ok Ã¶nemli bir farktÄ±r Kaan," diye yanÄ±tladÄ± Elara. "DoÄŸrusal Ã¶zyinelemeli sÃ¼reÃ§, ertelenmiÅŸ iÅŸlemler zinciri nedeniyle genellikle girdi boyutuyla orantÄ±lÄ± olarak artan bir bellek kullanÄ±rken, doÄŸrusal yinelemeli sÃ¼reÃ§ sabit miktarda bellekle yetinir. **Birincisi, Ã§Ã¶zdÃ¼ÄŸÃ¼ her alt problem iÃ§in yeni bir Ã§alÄ±ÅŸma alanÄ± aÃ§Ä±p, iÅŸi bitince kapatan bir dizi iÃ§ iÃ§e geÃ§miÅŸ ofise benzerken; ikincisi, tÃ¼m iÅŸi tek bir ofiste, mevcut araÃ§larÄ± sÃ¼rekli gÃ¼ncelleyerek yapan bir ustaya benzer.** Ä°ki sÃ¼reÃ§ de aynÄ± sonucu Ã¼retebilir, hatta aynÄ± sayÄ±da adÄ±m atabilir, ancak kaynak kullanÄ±mlarÄ±, Ã¶zellikle bellek tÃ¼ketimleri belirgin ÅŸekilde farklÄ±laÅŸÄ±r."
>
> > <span style="color:red;">â‘¥</span>
> > > [!TIP]
> > > `Recursive Procedure Syntax` {can_generate} `Iterative Process` {if} `Tail-Recursive Implementation exists`
>
> Elif dÃ¼ÅŸÃ¼nceli bir ÅŸekilde, "Usta, faktÃ¶riyel iÃ§in yazdÄ±ÄŸÄ±mÄ±z ikinci prosedÃ¼r (`fact-iter`), kendi kendini Ã§aÄŸÄ±rÄ±yordu, yani sÃ¶zdizimi (`syntax`) olarak Ã¶zyinelemeliydi (`recursive procedure`). Ama siz onun oluÅŸturduÄŸu sÃ¼recin yinelemeli (`iterative process`) olduÄŸunu sÃ¶ylediniz. Bu bir Ã§eliÅŸki deÄŸil mi?" diye sordu.
>
> Elara gÃ¼lÃ¼msedi. "Bu Ã§ok zekice bir soru ve programlamada sÄ±kÃ§a karÄ±ÅŸtÄ±rÄ±lan bir noktadÄ±r, Elif. Bir prosedÃ¼rÃ¼n 'Ã¶zyinelemeli' olmasÄ±, onun tanÄ±mÄ±nda kendi kendine doÄŸrudan veya dolaylÄ± bir Ã§aÄŸrÄ± yapmasÄ± anlamÄ±na gelen sÃ¶zdizimsel bir Ã¶zelliktir. Ancak bir sÃ¼recin 'Ã¶zyinelemeli' veya 'yinelemeli' olmasÄ±, o sÃ¼recin zaman iÃ§inde nasÄ±l evrildiÄŸiyle, bellek ve durum deÄŸiÅŸkenlerini nasÄ±l kullandÄ±ÄŸÄ±yla ilgilidir. Ä°yi tasarlanmÄ±ÅŸ bir yorumlayÄ±cÄ± veya derleyici, 'Kuyruk Ã–zyinelemesi'ne (`Tail Recursion`) sahipse, Ã¶zyinelemeli bir sÃ¶zdizimiyle yazÄ±lmÄ±ÅŸ bazÄ± prosedÃ¼rlerin aslÄ±nda yinelemeli bir sÃ¼reÃ§ oluÅŸturmasÄ±nÄ± saÄŸlayabilir. EÄŸer bir prosedÃ¼rdeki Ã¶zyinelemeli Ã§aÄŸrÄ±, prosedÃ¼rÃ¼n yapacaÄŸÄ± *en son* iÅŸlemse (yani Ã§aÄŸrÄ±dan sonra yapÄ±lacak baÅŸka bir iÅŸlem yoksa, sonuÃ§ doÄŸrudan geri dÃ¶ndÃ¼rÃ¼lÃ¼yorsa), o zaman yorumlayÄ±cÄ± bu Ã§aÄŸrÄ±yÄ± bir dÃ¶ngÃ¼ye dÃ¶nÃ¼ÅŸtÃ¼rerek fazladan bellek yÄ±ÄŸÄ±nÄ± (`stack space`) kullanmadan Ã§alÄ±ÅŸtÄ±rabilir. **Bunu, tek bir Ã§alÄ±ÅŸma masasÄ± (bellek alanÄ±/stack frame) olan bir zanaatkar gibi dÃ¼ÅŸÃ¼nebilirsin. Zanaatkar, bir projenin bir aÅŸamasÄ±nÄ± (prosedÃ¼rÃ¼n mevcut Ã§aÄŸrÄ±sÄ±nÄ±) bu masada tamamlar. EÄŸer projenin bir sonraki aÅŸamasÄ± (kuyruk Ã§aÄŸrÄ±sÄ±), aynÄ± projenin biraz farklÄ± malzemelerle (yeni argÃ¼manlarla) tekrar aynÄ± temel adÄ±mlarÄ± izleyerek yapÄ±lmasÄ±ysa, zanaatkar eski malzemeleri masadan temizler, yeni malzemeleri masaya koyar ve aynÄ± masayÄ± kullanarak iÅŸe baÅŸtan baÅŸlar. Yeni bir masa aÃ§masÄ±na (yeni bir bellek alanÄ± ayÄ±rmasÄ±na) gerek kalmaz, Ã§Ã¼nkÃ¼ bir Ã¶nceki aÅŸamayla ilgili masada tutmasÄ± gereken yarÄ±m kalmÄ±ÅŸ bir iÅŸ veya bir not yoktur. TÃ¼m bilgi, yeni malzemelerle bir sonraki dÃ¶ngÃ¼ye aktarÄ±lmÄ±ÅŸtÄ±r.** BÃ¶ylece, Ã¶zyinelemeli bir formda yazÄ±lmÄ±ÅŸ olmasÄ±na raÄŸmen, sÃ¼reÃ§ sabit bellekte, yani yinelemeli bir ÅŸekilde ilerler. `fact-iter` prosedÃ¼rÃ¼mÃ¼z tam da bÃ¶yle bir 'kuyruk Ã§aÄŸrÄ±sÄ±' (`tail call`) iÃ§erir."
>
> > <span style="color:red;">â‘¦</span>
> > > [!TIP]
> > > `Analysis: Processes Generated` {details} `Tree Recursive Process`
>
> Elara, kumun Ã¼zerine bu kez dallanÄ±p budaklanan bir aÄŸaÃ§ ÅŸekli Ã§izdi. "DoÄŸrusal sÃ¼reÃ§lerin yanÄ± sÄ±ra, 'AÄŸaÃ§ Ã–zyinelemesi' (`Tree Recursion`) dediÄŸimiz bir baÅŸka sÃ¼reÃ§ ÅŸekli daha vardÄ±r. Burada, bir prosedÃ¼r kendini birden fazla kez Ã§aÄŸÄ±rarak, dallanan bir sÃ¼reÃ§ yapÄ±sÄ± oluÅŸturur. **TÄ±pkÄ± bir aÄŸacÄ±n gÃ¶vdesinden Ã§Ä±kan ana dallarÄ±n, o dallardan Ã§Ä±kan daha kÃ¼Ã§Ã¼k dallara ayrÄ±lmasÄ± gibi.** Fibonacci sayÄ±larÄ±nÄ± hesaplamak iÃ§in yazdÄ±ÄŸÄ±mÄ±z ilk prosedÃ¼r, `(fib (- n 1))` ve `(fib (- n 2))` olmak Ã¼zere kendini iki kez Ã§aÄŸÄ±rÄ±yordu. Bu, her Ã§aÄŸrÄ±da sÃ¼recin ikiye ayrÄ±ldÄ±ÄŸÄ± bir aÄŸaÃ§ yapÄ±sÄ± oluÅŸturur. Bu tÃ¼r sÃ¼reÃ§ler, problemi alt problemlere ayÄ±rmanÄ±n doÄŸal bir yolunu sunduÄŸu iÃ§in bazÄ± durumlarda Ã§ok zariftir. Ancak, dikkatli olmazsak, **aynÄ± hazineyi bulmak iÃ§in bir labirentin aynÄ± koridorlarÄ±nÄ± defalarca gezen acemi bir kaÅŸif gibi,** aynÄ± alt problemleri tekrar tekrar hesaplayarak verimsizliÄŸe yol aÃ§abilirler. Fibonacci Ã¶rneÄŸinde, `(fib 3)` gibi bir deÄŸerin aÄŸacÄ±n farklÄ± dallarÄ±nda birÃ§ok kez hesaplandÄ±ÄŸÄ±nÄ± gÃ¶rmÃ¼ÅŸtÃ¼k."
>
> Kaan ve Elif, nehrin akÄ±ÅŸÄ±na ve Elara'nÄ±n Ã§izdiÄŸi ÅŸekillere bakarak, yazdÄ±klarÄ± basit prosedÃ¼rlerin bilgisayarÄ±n iÃ§inde ne kadar farklÄ± ve karmaÅŸÄ±k yaÅŸamlar oluÅŸturabileceÄŸini hayal etmeye Ã§alÄ±ÅŸÄ±yorlardÄ±. SoyutlamanÄ±n gÃ¼cÃ¼, sadece karmaÅŸÄ±klÄ±ÄŸÄ± yÃ¶netmekle kalmÄ±yor, aynÄ± zamanda bu sÃ¼reÃ§lerin verimliliÄŸini ve zarafetini de ÅŸekillendiriyordu.
> ```
{ #de999c}


---

## ğŸ”‘ Key Points
- 
## â“ Questions
- 
## ğŸ“¦ Resources
- PODCAST (IN TURKISH):![[The Story of Generated Processes-(InTurkish).wav]]
- PODCAST (IN ENGLISH):![[The Story of Generated Processes.wav]]
- PNG MINDMAP:[[8.GeneratedProcesses.png]]
## ğŸ¯ Actions
- [ ] 
- [ ] 
- [ ] 
- [ ] 
- [ ] 